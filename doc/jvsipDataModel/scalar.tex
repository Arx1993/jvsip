\subsection{Scalar}
The library exists to crunch data and the data exists as a bunch of scalars in memory. The scalar is defined to store data of a particular type in order to do some particular manipulation.  The type of manipulation being done and the type of data being stored define the kind of scalar needed. The scalar is a base type like a floating point number or an integer or it may be a more complicated type like complex or matrix index. For \cvl{} the scalars are all defined and available to the user in the public header file.  Some may be implementation dependent but (currently) the scalar definitions are available in the header file so creating data space and arrays of scalars using baseline library allocation is easy.
\\[6pt]
Scalars exist at the interface between the library and the user. Operations on views may return a scalar value but the scalar is produced by the operation.  The storage of the scalar internal to the library may not be scalar values at all.  When a block is created it enables storage of some number of scalar values but it need not store actual scalars; only the information the scalars will hold.
\\[6pt]
If sets of data are desired to be copied out of a \vw{} or attached to a \blk{} then an interface definition must be defined which associates the scalars available in the public space and the data stored in the library.
\\[6pt] 
In \pyjv{} I convert all scalars to a type that is consistent with normal \ttbf{python} data types and expect python functions to be used with these scalars. Under the covers, so to speak, I convert \pyjv{} scalars to \cvl{} scalars when calling underlying \cvl{} code. So \pyjv{} is somewhat of a hybrid because of the use for which it is designed. 
\\[6pt]
As I consider the differences between how I have done scalars in \pyjv{} compared to how I do it in \cvl{} I see there are really two models.  One model is a baseline VSIP library, the other is a hybrid VSIP library with direct ties to a real VSIP library. 
\\[6pt]
When doing a new VSIP library for a new language one must consider the use case for the new library and the limitations of the language.
\\[6pt]
In \cvl{} we have baseline atomic scalars such as integers and floating point values, and we have the library defined scalars \ttbf{complex}, \ttbf{matrix index,} and \ttbf{tensor index}.  We describe these scalars in terms of depth and precision. Generally precision is understood to be some number of bits of precision and depth is understood to be a number indicating how many atomic pieces a library defined scalar can be decomposed into. For instance a \ttbf{matrix index} can be decomposed into a \ttbf{row index} and a \ttbf{column index} and a \ttbf{complex} can be decomposed into two real floats one associated with the imaginary part  and one associated with the real part of the \ttbf{complex}.
\\[6pt]
I would like to extend scalar to a more abstract definition to include UML class definitions for Vendor defined scalars. This would allow a vendor to support any scalar type that made sense for a VSIPL library for a particular platform.