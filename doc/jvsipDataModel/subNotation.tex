\subsection{Notation}
In this section I define terminology and notation I use in this document. Some comes from previous VSIP work and some is specific to this paper study or my own idiosyncrasies.
\subsubsection{In General}
If I say \emph{in general} I am really saying we are restricted by the current \cvl{} specification but otherwise there is no reason not to extend the use to include more general functionality or cases. 
\subsubsection{Transpose VS Corner Turn}
I consider a transpose to be a mathematical operation on matrix views. Data may or may not move if a transpose is done. On the other hand I consider a corner turn to involve movement of data to achieve better data locality. Corner turns are frequently done to locate data to the proper node in a parallel process.
\subsubsection{\Blk{} and \Vw{} and \blk{} and \vw}
For this document a \Blk{} indicates the class including create/destroy operations and a \blk{} is the instantiated \Blk{} object. Similar for the \Vw{} being the class and \vw{} is the \Vw{} object.
\subsubsection{Users and Implementors}
In the \cvl{} specification we have two entities we specify for; the implementor and the user. 
\paragraph{The \ttbf{Implementor}} is the company, person, group, whatever who writes the library for use by others. This person is concerned about the requirements for the data model at a low level including how the \blk{} utilizes underlying memory resources.
\paragraph{The \ttbf{User}}is the person, company, group, whatever who will write software using the library as a tool. This person is concerned about managing data in the \blk{} and \vw{} format to efficiently process the data for the application the user is developing.
\paragraph{Comment}I note that ever since VSIPL was released the \ttbf{User} has been trying to pry open the \blk{} in order to directly access machine memory in the name of performance or convenience.  This may cause portability problems with user codes. I have not been convinced that the current blockbind/admit/release functionality will not work for most of the problems \ttbf{Users} are trying to solve.  Some use case diagrams (by \ttbf{Users} who want access to the block memory model) might be helpful to understand the problem. The problem seems to crop up frequently when moving data between a Host running VSIPL and a special processing device like a GPGPU. Still seems to me block bind should work.
\paragraph{Questions}It would be handy to have use case diagrams (or even a well written narrative) showing the need and use of the proposed direct data access method and why block bind will not work here.  Activity diagrams showing the work flow for the direct data access model would also be helpful.
\subsubsection{Function and type Naming Conventions}
I use the same notation as the \cvl{} specification but for those who are uninformed and don't want to read in the \cvl{} spec naming convention to produce a generic name an italic \emph{d} is used for some type of depth, an \emph{p}for some type of precision and an \emph{s} for some type of shape. Unfortunately in \cvl{} the matrix and tensor index are indicated in the \emph{p} spot even though they seem to me to be a depth. I am trying to generalize because I feel that perhaps at some time in the future we might have other depths beside complex and real.
\paragraph{Discusion}
In order to create the \Blk{} and \Vw{} objects the user needs to be able to communicate to the library the necessary metadata.  For a language such as C a lot of information is transferred via the function naming. Avoiding name collisions was the primary instigation for the \cvl{} naming convention.  For \pyjv{}, which is more object oriented, type information is indicated with strings using the \cvl{} naming convention; but the argument list is also used in \pyjv{} for function overloading.  For C++  information seems to be communicated with both templates and function naming.  For instance in \pyjv{} I just have a view class and the shape of  the \vw{} is indicated to the \Vw{} constructor argument list. The \Vw{} constructor is actually called by a \blk{} using the \ttbf{bind} method. So the scalar information needed to call the underlying \cvl{} constructors is provided by the block. Examples from the C++ proof of concept code done by Stefan use a \ttbf{Matrix} class so the shape is defined by the class constructor and the precision (and I suppose size) is defined by parameters. I am not sure if a \blk{} is involved at all for \ttbf{VSIPL++}. For \ttbf{VSIPL++} is a \blk{} only produced from a matrix or vector if an interface operation is being done?
\paragraph{Discussion}
While writing \pyjv{} I have noticed that for the current \cvl{} library all the information needed to create a view is the \ttbf{block} and the shape argument list.  The strings I have defined for view types are more for convenience than a necessity. Everything can be derived from the \vw{} attributes and the \blk{} type. I am not sure this would be true in general, but it seems to be true for \cvl{}.
\paragraph{Comment} In retrospect I am not sure the naming convention for \cvl{} was necessarily optimum. If we want to support more scalar types it can become unwieldily.  For instance I wonder if perhaps instead of \ttbf{vsip\_\emph{c}block\_\emph{p}} for complex we would have been better to use \ttbf{vsip\_block\_\emph{cp}}. In this way all the type information about the scalars the block stores reside in a scalar affix.  This affix would not necessarily need to be just one or two characters if more are needed for a particular implementation.  The point I am trying to make here is it a \emph{complex} \blk{} or is it a \blk{} that stores \emph{complex} scalars.
\subsubsection{Primary Functions and Convenience Functions}
Important functions, what I have termed primary, are the functions you can't do without. For instance in \cvl{} \ttbf{vsip\_\emph{ds}bind\_\emph{p}} is a primary function used to create a view and bind it to a (already created) \blk{}. The function \ttbf{vsip\_\emph{d}blockcreate\_\emph{p}} is a primary function used to create a \blk{}. The function \ttbf{vsip\_\emph{d}blockbind\_\emph{p}} is a primary function used to create an interface \blk{} and associate it with user defined memory. The function \ttbf{vsip\_\emph{d}blockrebind\_\emph{p}} is a primary function used to change an interface \blk{}s association to user memory.  There is no way to do these functions at a lower level with user code.
\\[6pt]
On the other hand a function like \ttbf{vsip\_\emph{ds}create\_\emph{p}} is a convenience function and will create a \blk{} and bind a \vw{} to it all in one step.  Functions like subview, row or column view, etc.  produce new view objects but could be done using primary functions. Functions which could be written by Users using primary function I call convenience functions.
\paragraph{Comment} It is my opinion that the primary functions define the data model, not the convenience functions.  In VSIPL++ it seems that all the functions are convenience functions.  It is difficult to find the data model when you only create matrices and vectors. Basically I don't understand the data model in VSIPL++ at all.  Do they even have a counterpart to \ttbf{bind}?  They seem to have blocks but I am not sure how they are associated with the matrix or vector.
%