\afuncT{qrd}{QR Decomposition Class}{overDeterminedSolver}
\\\cvsiplh 
\\ \hspace*{.8cm} \vspace*{.1cm} \textbf{Available Functions }
%
%
\\ \hspace*{1.cm}{
\ttfamily\vspace{.3cm}
\begin{tabular}[H]{|l|}
\multicolumn{1}{c}{\rmfamily \bfseries Calculate QR Decomposition\vspace{.1cm}}\\ \hline\Ts
int vsip\_qrd\_d(vsip\_qr\_d*, const vsip\_mview\_d*);\Bs\\
int vsip\_qrd\_f(vsip\_qr\_f*, const vsip\_mview\_f*);\Bs\\
int vsip\_cqrd\_d(vsip\_cqr\_d*, const vsip\_cmview\_d*);\Bs\\
int vsip\_cqrd\_f(vsip\_cqr\_f*, const vsip\_cmview\_f*);\Bs\\
\hline\end{tabular}\\}
%
\hspace*{1.cm} {
\ttfamily\vspace{.3cm}
\begin{tabular}[H]{|l|}
\multicolumn{1}{c}{\rmfamily \bfseries Create QRD Object\vspace{.1cm}}\\ \hline\Ts
vsip\_qr\_d* vsip\_qrd\_create\_d(vsip\_length);\Bs\\
vsip\_qr\_f* vsip\_qrd\_create\_f(vsip\_length);\Bs\\
vsip\_cqr\_d* vsip\_cqrd\_create\_d(vsip\_length);\Bs\\
vsip\_cqr\_f* vsip\_cqrd\_create\_f(vsip\_length);\Bs\\
\hline\end{tabular}\\}
%
\\ \hspace*{1.cm} {
\ttfamily\vspace{.3cm}
\begin{tabular}[H]{|l|}
\multicolumn{1}{c}{\rmfamily \bfseries Destroy QRD Object\vspace{.1cm}}\\ \hline\Ts
int vsip\_qrd\_destroy\_d(vsip\_qr\_d*);\Bs\\
int vsip\_qrd\_destroy\_f(vsip\_qr\_f*);\Bs\\
int vsip\_cqrd\_destroy\_d(vsip\_cqr\_d*);\Bs\\
int vsip\_cqrd\_destroy\_f(vsip\_cqr\_f*);\Bs\\
\hline\end{tabular}\\}
%
\\ \hspace*{1.cm}{
\ttfamily\vspace{.3cm}
\begin{tabular}[H]{|l|}
\multicolumn{1}{c}{\rmfamily \bfseries Fill QRD Attribute Structure\vspace{.1cm}}\\ \hline\Ts
void vsip\_qrd\_getattr\_d(const vsip\_qr\_d*, vsip\_qr\_attr\_d*);\Bs\\
void vsip\_qrd\_getattr\_f(const vsip\_qr\_f*, vsip\_qr\_attr\_f*);\Bs\\
void vsip\_cqrd\_getattr\_d(const vsip\_cqr\_d*, vsip\_cqr\_attr\_d*);\Bs\\
void vsip\_cqrd\_getattr\_f(const vsip\_cqr\_f*, vsip\_cqr\_attr\_f*);\Bs\\
\hline\end{tabular}\\}
%
\\ \hspace*{1.cm}{
\ttfamily\vspace{.3cm}
\begin{tabular}[H]{|l|}
\multicolumn{1}{c}{\rmfamily \bfseries Product with Q from QR Decomposition\vspace{.1cm}}\\ \hline\Ts
int vsip\_qrdprodq\_d(const vsip\_qr\_d*, vsip\_mat\_op, vsip\_mat\_side,\\*\hspace*{1cm}const vsip\_mview\_d*);\Bs\\
int vsip\_qrdprodq\_f(const vsip\_qr\_f*, vsip\_mat\_op, vsip\_mat\_side,\\*\hspace*{1cm}const vsip\_mview\_f*);\Bs\\
int vsip\_cqrdprodq\_d(const vsip\_cqr\_d*, vsip\_mat\_op, vsip\_mat\_side,\\*\hspace*{1cm}const vsip\_cmview\_d*);\Bs\\
int vsip\_cqrdprodq\_f(const vsip\_cqr\_f*, vsip\_mat\_op, vsip\_mat\_side,\\*\hspace*{1cm}const vsip\_cmview\_f*);\Bs\\
\hline\end{tabular}\Bs\\}
%
%
\\ \hspace*{1.cm}{
\ttfamily\vspace{.3cm}
\begin{tabular}[H]{|l|}
\multicolumn{1}{c}{\rmfamily \bfseries Solve Linear System Based on R from QR Decomposition\vspace{.1cm}}\\ \hline\Ts
int vsip\_qrdsolr\_d(const vsip\_qr\_d *, vsip\_mat\_op opR, vsip\_scalar\_d,\\*\hspace*{1cm}const vsip\_mview\_d *);\Bs\\
int vsip\_qrdsolr\_f(const vsip\_qr\_f *, vsip\_mat\_op opR, vsip\_scalar\_f,\\*\hspace*{1cm}const vsip\_mview\_f *);\Bs\\
int vsip\_cqrdsolr\_d(const vsip\_cqr\_d *, vsip\_mat\_op opR, vsip\_cscalar\_d,\\*\hspace*{1cm}const vsip\_cmview\_d *);\Bs\\
int vsip\_cqrdsolr\_f(const vsip\_cqr\_f *, vsip\_mat\_op opR, vsip\_cscalar\_f,\\*\hspace*{1cm}const vsip\_cmview\_f *);\Bs\\
\hline\end{tabular}\Bs\\}
%
\\ \hspace*{1.cm}{
\ttfamily\vspace{.3cm}
\begin{tabular}[H]{|l|}
\multicolumn{1}{c}{\rmfamily \bfseries Use QRD to Solve a Covariance or LLSQ System\vspace{.1cm}}\\ \hline\Ts
int vsip\_qrsol\_d(const vsip\_qr\_d*, vsip\_qrd\_prob,\\*\hspace*{1cm}const vsip\_mview\_d*);\Bs\\
int vsip\_qrsol\_f(const vsip\_qr\_f*, vsip\_qrd\_prob,\\*\hspace*{1cm}const vsip\_mview\_f*);\Bs\\
int vsip\_cqrsol\_d(const vsip\_cqr\_d*, vsip\_qrd\\\*\hspace*{1cm}, const vsip\_cmview\_d*);\Bs\\
int vsip\_cqrsol\_f(const vsip\_cqr\_f*, vsip\_qrd\_prob,\\*\hspace*{1cm}const vsip\_cmview\_f*);\Bs\\
\hline\end{tabular}\Bs\\}
%
\\\pyjvsiph
%
\\ \hspace*{.8cm}{\textbf{View Methods\vspace{.2cm}}\\
\hspace*{1.1cm}\parbox{.9\textwidth}{
\begin{itemize}
\item {Two \ttbf{view} methods have been defined for QR Decompostion.}
\subitem{\ttbf{qrd} - A method to obtain matrices \ttbf{Q} and \ttbf{R} from a matrix.\Bs}
\subitem{\ttbf{qr} - A method to obtain a computed QR object from a matrix.\Bs}
\item{Vector \ttbf{view}s are treated as a matrix with a single column.\Bs}
\item{\Ts Both \ttbf{view} methods are defined as properties.}
\end{itemize}\vspace{2mm}}}\\
%%
\hspace*{1.1cm}\textbf{Example: }\vspace*{.1cm}\\
\hspace*{1.9cm}\parbox{.85\textwidth}{\Ts Assume matrix \ttbf{view} \ttbf{A} has been created and has data in it.}\\
\hspace*{1.9cm}\parbox{.8\textwidth}{\vspace{.3cm}\hspace*{1cm}\ttbf{qrObj=A.qr} \\*
will create a full \ttbf{QR} using flag \ttbf{VSIP\_QRD\_SAVEQ} and decompose the matrix.}\\
\hspace*{1.9cm}\parbox{.8\textwidth}{\vspace{.3cm}\hspace*{1cm}\ttbf{Q,R=A.qrd} \\*
will create matrix \ttbf{Q} and matrix \ttbf{R} using \ttbf{QR} and \ttbf{A} such that \ttbf{A = Q.prod(R)}}\\
%
\hspace*{.8cm}\textbf{QR Class\vspace{.2cm}}\\
\hspace*{1.1cm}\parbox{.9\textwidth}{To create an QR object use \\*
\hspace*{1.cm} \ttbf{qrObj=QR(t,m,n,qSave)}\\*
where:
\begin{itemize}
\item \ttbf{t} is a string indicating the QR type
\item \ttbf{m} is the column length
\item \ttbf{n} is the row length
\item \ttbf{qSave} is a flag indicating how much of the Q matrix is to be saved.
\end{itemize} \vspace{.2cm}}\\
%%
\begin{table}
\caption{Flags and Types for QR Decomposition}
\begin{center}\begin{tabular}{|l l|}
\multicolumn{2}{c}{\Ts\parbox[t]{.6\textwidth}{\center{\rmfamily \bfseries QR Decomposition Types}}}\Bs\\\hline
'qr\_d' & Real \ttbf{QR}; double precision \Bs\\\hline
'qr\_f' & Real \ttbf{QR}; float precision\Bs\\\hline
'cqr\_d' & Complex \ttbf{QR}; double precision\Bs\\\hline
'cqr\_f' & Complex \ttbf{QR}; float precision\Bs\\\hline
%%%
\multicolumn{2}{c}{\parbox[t]{.6\textwidth}{\center{\rmfamily \bfseries Q Save Flags}}}\Bs\\\hline
\Ts'NOSAVEQ' or \ttbf{VSIP\_QRD\_NOSAVEQ} & Do not save Q matrix\Bs\\\hline
'SAVEQ' or \ttbf{VSIP\_QRD\_SAVEQ} & Save full Q matrix\Bs\\\hline
'SAVEQ1' or \ttbf{VSIP\_QRD\_SAVEQ1} & Save skinny Q matrix\Bs\\\hline
%%%
\multicolumn{2}{c}{\parbox[t]{.6\textwidth}{\center{\rmfamily \bfseries QR Solve Problem Flags (\ttbf{prob})}}}\Bs\\\hline
\Ts'COV' or \ttbf{VSIP\_COV} & Solve Covariance Problem\Bs\\\hline
'LLS' or \ttbf{VSIP\_LLS} & Solve Linear Least Square Problem\Bs\\\hline
%%%
\multicolumn{2}{c}{\parbox[t]{.6\textwidth}{\center{\rmfamily \bfseries Matrix Operator Flags (\ttbf{op})}}}\Bs\\\hline
\Ts'NTRANS' or \ttbf{VSIP\_MAT\_NTRANS} & No Transpose operator\Bs\\\hline
   'TRANS' or \ttbf{VSIP\_MAT\_TRANS} & Transpose operator\Bs\\\hline
   'HERM' or \ttbf{VSIP\_MAT\_HERM} & Hermitian operator\Bs\\\hline
%%%
\multicolumn{2}{c}{\parbox[t]{.6\textwidth}{\center{\rmfamily \bfseries Side Flag}}}\Bs\\\hline
\Ts'LSIDE' or \ttbf{VSIP\_MAT\_LSIDE} & \ttbf{Q} matrix on the left side\Bs\\\hline
   'RSIDE' or \ttbf{VSIP\_MAT\_RSIDE} & \ttbf{Q} matrix on the right side\Bs\\\hline
 \end{tabular}\end{center}\end{table}
%%
\hspace*{1.1cm}{\textbf{QR Class Methods}\\
\hspace*{1.1cm} \parbox[t]{.9\textwidth}{For class methods table we assume we have created an QR object we call \ttbf{qrObj} and we have an input \ttbf{view A} compliant with \ttbf{firObj} and a compliant output \ttbf{view y}.\vspace{.2cm}}
\\
\hspace*{1.cm}\parbox[t]{.85\textwidth}{\begin{tabular}{|l l|}
\multicolumn{2}{c}{\parbox[t]{.58\textwidth}{\center{\rmfamily \bfseries QR Decomposition Methods\vspace{.2cm}}}}\Bs\\ \hline
%
\Ts\ttbf{qrObj.decompose(A)} & 
\parbox[t]{.58\textwidth}{Decompose \ttbf{A}. Results are in QR object}\Bs\\\hline
%
\ttbf{qrObj.args} & 
\parbox[t]{.58\textwidth}{Property. Return tuple consisting of input argument \ttbf{(m,n,qSave)} list for creation of QR}\Bs\\\hline
%
\ttbf{qrObj.qSize} & 
\parbox[t]{.58\textwidth}{Returns size of Q matrix represented by QR decomposition.}\Bs\\\hline
%
\ttbf{qrObj.size} & 
\parbox[t]{.58\textwidth}{Property. Returns size of input matrix to \ttbf{decompose} method \ttbf{(m,n)} \vspace*{.1cm}}\Bs\\\hline
%
\ttbf{qrObj.type} & 
\parbox[t]{.58\textwidth}{Property. Returns string indicating QR type.\vspace*{.1cm}}\Bs\\\hline
%
\ttbf{qrObj.vsip} & 
\parbox[t]{.58\textwidth}{Property. Returns C VSIPL QR instance.\vspace*{.1cm}}\\\hline
%
\ttbf{qrObj.solve(prob,XB)} & \parbox[t]{.58\textwidth}{Solve}\\\hline
%
\ttbf{qrObj.solveR(op,alpha,XB)} & \parbox[t]{.58\textwidth}{Solve using \ttbf{R} matrix from QR decompostion.\vspace*{.1cm}}\\\hline
%
\ttbf{qrObj.prodQ(op,side,XB)} &
 \parbox[t]{.58\textwidth}{Matrix product of \ttbf{Q} with \ttbf{X}.}\\\hline
%
\end{tabular}\vspace*{.4cm}}\\
\hspace*{.7cm} \parbox[t]{.91\textwidth}{
\begin{itemize}
\item{View \ttbf{XB} is an input-output view. Since the output may be of a different size than the input care must be used to use an input view with a block large enough to handle the expected output. Note for the solvers one would consider \ttbf{B} as the input and \ttbf{X} as the output and for the product vice versa.}
\item{There is no method defined by the \ttbf{VSIPL} specification to get the \ttbf{Q} or \ttbf{R} matrices explicitly. This information is held in the \ttbf{QR} object. For the \ttbf{qrd view} method these are calculated using the \ttbf{QR prodQ} method.}
\item{Constant \ttbf{alpha} in the \ttbf{solveR} method is a multiplier on input \ttbf{B}.}
\item{\ttbf{QR} is a bit busy. Reading the C VSIPL specification should help in understanding the constants and Flags.}
\end{itemize}}