\afuncT{lud}{Lower-Upper Decomposition Class.}{generalSquareSolver}
\\\cvsiplh 
\\ \hspace*{.8cm} \vspace*{.1cm} \textbf{Available Functions }
%
%\\ \hspace*{.8cm} \vspace*{.1cm} \texttt{lud\_create}
\\ \hspace*{1.cm} {
\ttfamily\vspace{.3cm}
\begin{tabular}[H]{|l|}
\multicolumn{1}{c}{\rmfamily \bfseries Create LU Object\vspace{.1cm}}\\ \hline
vsip\_lu\_d* vsip\_lud\_create\_d(vsip\_length);\\
vsip\_lu\_f* vsip\_lud\_create\_f(vsip\_length);\\
vsip\_clu\_d* vsip\_clud\_create\_d(vsip\_length);\\
vsip\_clu\_f* vsip\_clud\_create\_f(vsip\_length);\\
\hline\end{tabular}\\}
%
%\\ \hspace*{.8cm} \vspace*{.1cm} \texttt{lud\_destroy}
\\ \hspace*{1.cm} {
\ttfamily\vspace{.3cm}
\begin{tabular}[H]{|l|}
\multicolumn{1}{c}{\rmfamily \bfseries Destroy LU Object\vspace{.1cm}}\\ \hline
int vsip\_lud\_destroy\_d(vsip\_lu\_d*);\\
int vsip\_lud\_destroy\_f(vsip\_lu\_f*);\\
int vsip\_clud\_destroy\_d(vsip\_clu\_d*);\\
int vsip\_clud\_destroy\_f(vsip\_clu\_f*);\\
\hline\end{tabular}\\}
%
%\\ \hspace*{.8cm} \vspace*{.1cm} \texttt{lud}
\\ \hspace*{1.cm}{
\ttfamily\vspace{.3cm}
\begin{tabular}[H]{|l|}
\multicolumn{1}{c}{\rmfamily \bfseries Calculate LU Decomposition\vspace{.1cm}}\\ \hline
int vsip\_lud\_d(vsip\_lu\_d*, const vsip\_mview\_d*);\\
int vsip\_lud\_f(vsip\_lu\_f*, const vsip\_mview\_f*);\\
int vsip\_clud\_d(vsip\_clu\_d*, const vsip\_cmview\_d*);\\
int vsip\_clud\_f(vsip\_clu\_f*, const vsip\_cmview\_f*);\\
\hline\end{tabular}\\}
%
%\\ \hspace*{.8cm} \vspace*{.1cm} \texttt{lusol}\\
\\ \hspace*{1.cm}{
\ttfamily\vspace{.3cm}
\begin{tabular}[H]{|l|}
\multicolumn{1}{c}{\rmfamily \bfseries Solve Using Calculated LU Decomposition\vspace{.1cm}}\\ \hline
int vsip\_lusol\_d(const vsip\_lu\_d*, vsip\_mat\_op, const vsip\_mview\_d*);\\
int vsip\_lusol\_f(const vsip\_lu\_f*, vsip\_mat\_op, const vsip\_mview\_f*);\\
int vsip\_clusol\_d(const vsip\_clu\_d*, vsip\_mat\_op, const vsip\_cmview\_d*);\\
int vsip\_clusol\_f(const vsip\_clu\_f*, vsip\_mat\_op, const vsip\_cmview\_f*);\\
\hline\end{tabular}\\}
%
%\\ \hspace*{.8cm} \vspace*{.1cm} \texttt{lud\_getattr}
\\ \hspace*{1.cm}{
\ttfamily\vspace{.3cm}
\begin{tabular}[H]{|l|}
\multicolumn{1}{c}{\rmfamily \bfseries Fill LU Attribute Structure\vspace{.1cm}}\\ \hline
void vsip\_lud\_getattr\_d(const vsip\_lu\_d*, vsip\_lu\_attr\_d*);\\
void vsip\_lud\_getattr\_f(const vsip\_lu\_f*, vsip\_lu\_attr\_f*);\\
void vsip\_clud\_getattr\_d(const vsip\_clu\_d*, vsip\_clu\_attr\_d*);\\
void vsip\_clud\_getattr\_f(const vsip\_clu\_f*, vsip\_clu\_attr\_f*);\\
\hline\end{tabular}\\}
%
\\ \pyjvsiph
\\ \hspace*{.8cm}{\textbf{View Methods\vspace{.2cm}}\\
\hspace*{1.1cm}\parbox{.9\textwidth}{
\begin{itemize}
\item {three \ttbf{view} methods have been defined for LU Decompostion.}
\subitem{\ttbf{luSolve{(xb)}} -Calculate an in-place solution to $A\vec{x}=\vec{b}$ or $A X = B$.\Bs}
\subitem{\ttbf{luInv} - A method to obtain a matrix inverse using LU for computation.}
\subitem{\ttbf{lu} - A method to obtain a computed LU object from a matrix.\Bs}
\item{\Ts Methods \ttbf{lu} and \ttbf{luInv} are defined as properties.}
\item{LU decomposition will overwrite the input matrix so use a copy to preserve the calling view.}
\end{itemize}\vspace{2mm}}}\\
%%
\hspace*{1.1cm}\textbf{Example: }\vspace*{.1cm}\\
\hspace*{1.9cm}\parbox{.85\textwidth}{\Ts Assume matrix \ttbf{view} \ttbf{A} has been created and has data in it.}\\
\hspace*{1.9cm}\parbox{.8\textwidth}{\vspace{.3cm}\hspace*{1cm}\ttbf{qrObj=A.qr} \\*
will create a full \ttbf{QR} using flag \ttbf{VSIP\_QRD\_SAVEQ} and decompose the matrix.}\\
\hspace*{1.9cm}\parbox{.8\textwidth}{\vspace{.3cm}\hspace*{1cm}\ttbf{Q,R=A.qrd} \\*
will create matrix \ttbf{Q} and matrix \ttbf{R} using \ttbf{QR} and \ttbf{A} such that \ttbf{A = Q.prod(R)}}\\
%
%
\hspace*{.8cm}{\textbf{LUD Class Methods}\\
\hspace*{1.1cm} \parbox[t]{.88\textwidth}{For class methods table we assume we have created an LUD object we call \ttbf{firObj} and we have an input \ttbf{view x} compliant with \ttbf{firObj} and a compliant output \ttbf{view y}.\vspace{.2cm}}
\\
\hspace*{1.cm}\parbox[t]{.85\textwidth}{\begin{tabular}{|l l|}
\multicolumn{2}{c}{\parbox[t]{.58\textwidth}{\center{\rmfamily \bfseries Finite Impulse Response Filter Methods\vspace{.2cm}}}}\\ \hline
\ttbf{firObj.flt(x,y)} & \parbox[t]{.58\textwidth}{Filter the data \ttbf{x} and place the results in \ttbf{y}}\\\hline
\ttbf{firObj.decimation} & \parbox[t]{.58\textwidth}{ Returns integer decimation factor. \vspace*{.1cm}}\\\hline
\ttbf{firObj.length} & \parbox[t]{.58\textwidth}{ Returns integer length for \ttbf{x}. \vspace*{.1cm}}\\\hline
\ttbf{firObj.lengthOut} & \parbox[t]{.58\textwidth}{ Returns integer of valid data points in \ttbf{y} \vspace*{.1cm}}\\\hline
\ttbf{firObj.reset} & \parbox[t]{.58\textwidth}{Resets LUD filter to it's initial state. \vspace*{.1cm}}\\\hline
\ttbf{firObj.state} & \parbox[t]{.58\textwidth}{Returns \ttbf{True} if filter state is saved, otherwise returns \ttbf{False}.\vspace*{.1cm}}\\\hline
\ttbf{firObj.type} & \parbox[t]{.58\textwidth}{Returns string indicating filter type.\vspace*{.1cm}}\\\hline
\ttbf{firObj.vsip} & \parbox[t]{.58\textwidth}{Returns C VSIPL filter instance.\vspace*{.1cm}}\\\hline
\end{tabular}\vspace*{.4cm}}\\
\hspace*{.7cm} \parbox[t]{.91\textwidth}{
\begin{itemize}
\item{Methods \ttbf{decimation}, \ttbf{length}, \ttbf{state}, \ttbf{type} and \ttbf{vsip} are set when the LUD instance is created and do not change after create}
\item{Method \ttbf{lengthOut}\footnotemark[2] is calculated during the execution of method \ttbf{flt(x,y)} and is useful if state is saved and the filter object is used multiple times on a long piece of data.}
\item{Method \ttbf{reset} is used if state is saved and the filter is used multiple times on a long data set and then \emph{reset}\footnotemark[3] to it's initial state for use on multiple long data sets.}
\end{itemize}}
\footnotetext[1]{This does not preclude symmetric kernels. You just need the entire kernel.}
\footnotetext[2]{See C VSIPL specification for more information on length of output data.}
\footnotetext[3]{See signal processing text on overlap-add and overlap-save filtering.}
