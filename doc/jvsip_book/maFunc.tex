\afunc{ma}{Multiply and add. An element-wise function. See ternary functions table \ref{tab:ternaryOperations}.}
\cvsiplh
\newline \hspace*{.8cm} \vspace*{.1cm} \textbf{Available Functions }
\newline \hspace*{1.1cm} {
\ttfamily
\begin{tabular}[H]{l}
void vsip\_cvma\_d(const vsip\_cvview\_d*, const vsip\_cvview\_d*,\\*\hspace{.7cm}const vsip\_cvview\_d*, const vsip\_cvview\_d*);\\
void vsip\_cvma\_f(const vsip\_cvview\_f*, const vsip\_cvview\_f*,\\*\hspace{.7cm}const vsip\_cvview\_f*, const vsip\_cvview\_f*);\\
void vsip\_cvsma\_d(const vsip\_cvview\_d*, vsip\_cscalar\_d,\\*\hspace{.7cm}const vsip\_cvview\_d*, const vsip\_cvview\_d*);\\
void vsip\_cvsma\_f(const vsip\_cvview\_f*, vsip\_cscalar\_f,\\*\hspace{.7cm}const vsip\_cvview\_f*, const vsip\_cvview\_f*);\\
void vsip\_vma\_d(const vsip\_vview\_d*, const vsip\_vview\_d*,\\*\hspace{.7cm}const vsip\_vview\_d*, const vsip\_vview\_d*);\\
void vsip\_vma\_f(const vsip\_vview\_f*, const vsip\_vview\_f*,\\*\hspace{.7cm}const vsip\_vview\_f*, const vsip\_vview\_f*);\\
void vsip\_vsma\_d(const vsip\_vview\_d*, vsip\_scalar\_d,\\*\hspace{.7cm}const vsip\_vview\_d*, const vsip\_vview\_d*);\\
void vsip\_vsma\_f(const vsip\_vview\_f*, vsip\_scalar\_f,\\*\hspace{.7cm}const vsip\_vview\_f*, const vsip\_vview\_f*);\\
\end{tabular}
}
\pyjvsiph
\viewmthd{No}{NA}{NA}{NA}
\apyfunc{yes}{out = ma(in1,in2,in3,out)}
\newline\hspace*{1.2cm}\parbox{10.8cm}{\vspace*{.1cm}The \ttbf{log} function works much the same as the C VSIPL version except that a convenience pointer to the output view is returned. This may be done in-place if \ttbf{in==out}.}