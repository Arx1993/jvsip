\afunc{conj}{Conjugate each element in a view. An Unary Operations. See table \ref{tab:unaryOperations}}
\cvsiplh
\newline \hspace*{.8cm} \vspace*{.1cm} \textbf{Available Functions }
\newline \hspace*{1.1cm} {
\ttfamily
\begin{tabular}[H]{l}
vsip\_cscalar\_d vsip\_conj\_d(vsip\_cscalar\_d);\\
vsip\_cscalar\_f vsip\_conj\_f(vsip\_cscalar\_f);\\
void vsip\_cmconj\_d(\\*\hspace*{1cm}const vsip\_cmview\_d*, const vsip\_cmview\_d*);\\
void vsip\_cmconj\_f(\\*\hspace*{1cm}const vsip\_cmview\_f*, const vsip\_cmview\_f*);\\
void vsip\_cvconj\_d(\\*\hspace*{1cm}const vsip\_cvview\_d*, const vsip\_cvview\_d*);\\
void vsip\_cvconj\_f(\\*\hspace*{1cm}const vsip\_cvview\_f*, const vsip\_cvview\_f*);\\
\end{tabular}
}
\pyjvsiph
\viewmthd{yes}{yes}{yes}{inOut.conj}
\apyfunc{yes}{out = conj(in,out)}
\pyComment{
\item{The \ttbf{conj} function works much the same as the C VSIPL version except that a convenience pointer to the output view is returned. This may be done in-place if \ttbf{in==out}.}
\item{If the calling \ttbf{view} for the \ttbf{conj} method is real no error is generated. This case is basically a no operation. This is not true for the \ttbf{conj} function call which will generate an assert error as an unsupported type.}
}