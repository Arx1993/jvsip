\afuncT{prod4}{Special matrix product for 4 by 4 \ttbf{views}}{matrixOperations}
\\\cvsiplh
\\ \hspace*{.8cm} \vspace*{.1cm} \textbf{Available Functions }
\\ \hspace*{.03\textwidth} {
\ttfamily
\begin{tabular*}{.92\textwidth}[H]{l}
void vsip\_cmprod4\_d(\\*\hspace{.6cm}const vsip\_cmview\_d*, const vsip\_cmview\_d*, const vsip\_cmview\_d*);\Bs\\
void vsip\_cmprod4\_f(\\*\hspace{.6cm}const vsip\_cmview\_f*, const vsip\_cmview\_f*, const vsip\_cmview\_f*);\Bs\\
void vsip\_cmvprod4\_d(\\*\hspace{.6cm}const vsip\_cmview\_d*, const vsip\_cvview\_d*, const vsip\_cvview\_d*);\Bs\\
void vsip\_cmvprod4\_f(\\*\hspace{.6cm}const vsip\_cmview\_f*, const vsip\_cvview\_f*, const vsip\_cvview\_f*);\Bs\\
void vsip\_mprod4\_d(\\*\hspace{.6cm}const vsip\_mview\_d*, const vsip\_mview\_d*, const vsip\_mview\_d*);\Bs\\
void vsip\_mprod4\_f(\\*\hspace{.6cm}const vsip\_mview\_f*, const vsip\_mview\_f*, const vsip\_mview\_f*);\Bs\\
void vsip\_mvprod4\_d(\\*\hspace{.6cm}const vsip\_mview\_d*, const vsip\_vview\_d*, const vsip\_vview\_d*);\Bs\\
void vsip\_mvprod4\_f(\\*\hspace{.6cm}const vsip\_mview\_f*, const vsip\_vview\_f*, const vsip\_vview\_f*);\Bs\\
\end{tabular*}
}
\\\pyjvsiph
\viewmthd{yes}{No}{No}{out=inOne.prod(inTwo)}
\apyfunc{yes}{out = prod4(inOne,inTwo,out)}
\pyComment{
\item{The \ttbf{prod4} function works much the same as the C VSIPL version except that a
 convenience pointer to the output view is returned. This may not be done in-place.}
\item{There is no special \ttbf{prod4} method. The \ttbf{prod} method will select and 
use the \ttbf{prod4} C VSIPL routine if the conditions
exist to support it.}
}