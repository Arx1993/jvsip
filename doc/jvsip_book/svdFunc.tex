\afuncT{svd}{Singular Value Decomposition Class}{singularValueDecompostion}
\\\cvsiplh 
\\ \hspace*{.8cm} \vspace*{.1cm} \textbf{Available Functions }
%
%\\ \hspace*{.8cm} \vspace*{.1cm} \texttt{svd\_create}
\\ \hspace*{1.cm} {
\ttfamily\vspace{.3cm}
\begin{tabular}[H]{|l|}
\multicolumn{1}{c}{\rmfamily \bfseries Create SVD Object\vspace{.1cm}}\\ \hline \Ts
vsip\_sv\_d* vsip\_svd\_create\_d(vsip\_length, vsip\_length,\\*\hspace*{1cm}vsip\_svd\_uv , vsip\_svd\_uv);\Bs\\
vsip\_sv\_f* vsip\_svd\_create\_f(vsip\_length, vsip\_length,\\*\hspace*{1cm}vsip\_svd\_uv , vsip\_svd\_uv);\Bs\\
vsip\_csv\_d* vsip\_csvd\_create\_d(vsip\_length, vsip\_length,\\*\hspace*{1cm}vsip\_svd\_uv , vsip\_svd\_uv);\Bs\\
vsip\_csv\_f* vsip\_csvd\_create\_f(vsip\_length, vsip\_length,\\*\hspace*{1cm}vsip\_svd\_uv , vsip\_svd\_uv);\Bs\\
\hline\end{tabular}\\}
%
%\\ \hspace*{.8cm} \vspace*{.1cm} \texttt{svd\_destroy}
\\ \hspace*{1.cm} {
\ttfamily\vspace{.3cm}
\begin{tabular}[H]{|l|}
\multicolumn{1}{c}{\rmfamily \bfseries Destroy SVD Object\vspace{.1cm}}\\ \hline\Ts
int vsip\_svd\_destroy\_d(vsip\_sv\_d*);\Bs\\
int vsip\_svd\_destroy\_f(vsip\_sv\_f*);\Bs\\
int vsip\_csvd\_destroy\_d(vsip\_csv\_d*);\Bs\\
int vsip\_csvd\_destroy\_f(vsip\_csv\_f*);\Bs\\
\hline\end{tabular}\\}
%
%\\ \hspace*{.8cm} \vspace*{.1cm} \texttt{svd}
\\ \hspace*{1.cm}{
\ttfamily\vspace{.3cm}
\begin{tabular}[H]{|l|}
\multicolumn{1}{c}{\rmfamily \bfseries Compute SVD\vspace{.1cm}}\\ \hline \Ts
int vsip\_svd\_d(vsip\_sv\_d*, const vsip\_mview\_d*, vsip\_vview\_d*);\Bs\\
int vsip\_svd\_f(vsip\_sv\_f*, const vsip\_mview\_f*, vsip\_vview\_f*);\Bs\\
int vsip\_csvd\_d(vsip\_csv\_d*, const vsip\_cmview\_d*, vsip\_vview\_d*);\Bs\\
int vsip\_csvd\_f(vsip\_csv\_f*, const vsip\_cmview\_f*, vsip\_vview\_f*);\Bs\\
\hline\end{tabular}\\}
%
%\\ \hspace*{.8cm} \vspace*{.1cm} \texttt{svd\_getattr}
\\ \hspace*{1.cm}{
\ttfamily\vspace{.3cm}
\begin{tabular}[H]{|l|}
\multicolumn{1}{c}{\rmfamily \bfseries Fill SVD Attribute Structure\vspace{.1cm}}\\ \hline \Ts
void vsip\_svd\_getattr\_d(const vsip\_sv\_d*,  vsip\_sv\_attr\_d*);\Bs\\
void vsip\_svd\_getattr\_f(const vsip\_sv\_f*,  vsip\_sv\_attr\_f*);\Bs\\
void vsip\_csvd\_getattr\_d(const vsip\_csv\_d*,  vsip\_csv\_attr\_d*);\Bs\\
void vsip\_csvd\_getattr\_f(const vsip\_csv\_f*,  vsip\_csv\_attr\_f*);\Bs\\
\hline\end{tabular}\\}
%
\\ \hspace*{0.4cm} {
\ttfamily\vspace{.3cm}
\begin{tabular}[H]{|l|}
\multicolumn{1}{c}{\rmfamily \bfseries Product with U from SV Decomposition\vspace{.1cm}}\\ \hline\Ts
\Ts int vsip\_svdprodu\_f(const vsip\_sv\_f*,vsip\_mat\_op, vsip\_mat\_side,\\*\hspace*{1cm}const vsip\_mview\_f*);\Bs\\
int vsip\_csvdprodu\_f(const vsip\_csv\_f*, vsip\_mat\_op, vsip\_mat\_side,\\*\hspace*{1cm}const vsip\_cmview\_f*);\Bs\\
int vsip\_svdprodu\_d(const vsip\_sv\_d*, vsip\_mat\_op, vsip\_mat\_side,\\*\hspace*{1cm}const vsip\_mview\_d*);\Bs\\
int vsip\_svdprodu\_f(const vsip\_sv\_f*, vsip\_mat\_op, vsip\_mat\_side,\\*\hspace*{1cm}const vsip\_mview\_f*);\Bs\\
int vsip\_csvdprodu\_d(const vsip\_csv\_d*, vsip\_mat\_op, vsip\_mat\_side,\\*\hspace*{1cm}const vsip\_cmview\_d*);\Bs\\
int vsip\_csvdprodu\_f(const vsip\_csv\_f*, vsip\_mat\_op, vsip\_mat\_side,\\*\hspace*{1cm}const vsip\_cmview\_f*);\Bs\\
\hline\end{tabular}\\}
%
\\ \hspace*{0.4cm} {
\ttfamily\vspace{.3cm}
\begin{tabular}[H]{|l|}
\multicolumn{1}{c}{\rmfamily \bfseries Product with U from SV Decomposition\vspace{.1cm}}\\ \hline \Ts
int vsip\_svdprodv\_f(const vsip\_sv\_f*,vsip\_mat\_op, vsip\_mat\_side,\\*\hspace*{1cm}const vsip\_mview\_f*);\Bs\\
int vsip\_csvdprodv\_f(const vsip\_csv\_f*, vsip\_mat\_op, vsip\_mat\_side,\\*\hspace*{1cm}const vsip\_cmview\_f*);\Bs\\
int vsip\_svdprodv\_d(const vsip\_sv\_d*, vsip\_mat\_op, vsip\_mat\_side,\\*\hspace*{1cm}const vsip\_mview\_d*);\Bs\\
int vsip\_svdprodv\_f(const vsip\_sv\_f*, vsip\_mat\_op, vsip\_mat\_side,\\*\hspace*{1cm}const vsip\_mview\_f*);\Bs\\
int vsip\_csvdprodv\_d(const vsip\_csv\_d*, vsip\_mat\_op, vsip\_mat\_side,\\*\hspace*{1cm}const vsip\_cmview\_d*);\Bs\\
int vsip\_csvdprodv\_f(const vsip\_csv\_f*, vsip\_mat\_op, vsip\_mat\_side,\\*\hspace*{1cm}const vsip\_cmview\_f*);\Bs\\
\hline\end{tabular}\\}
%
\\ \hspace*{1.cm} {
\ttfamily\vspace{.3cm}
\begin{tabular}[H]{|l|}
\multicolumn{1}{c}{\rmfamily \bfseries Return with U from SV Decomposition\vspace{.1cm}}\\ \hline\Ts
int vsip\_svdmatu\_f(const vsip\_sv\_f*, vsip\_scalar\_vi, \\*\hspace*{1cm}vsip\_scalar\_vi, const vsip\_mview\_f*);\Bs\\
int vsip\_csvdmatu\_f(const vsip\_csv\_f*, vsip\_scalar\_vi, \\*\hspace*{1cm}vsip\_scalar\_vi, const vsip\_cmview\_f*);\Bs\\
int vsip\_svdmatu\_d(const vsip\_sv\_d*, vsip\_scalar\_vi, \\*\hspace*{1cm}vsip\_scalar\_vi, const vsip\_mview\_d*);\Bs\\
int vsip\_csvdmatu\_d(const vsip\_csv\_d*, vsip\_scalar\_vi, \\*\hspace*{1cm}vsip\_scalar\_vi, const vsip\_cmview\_d*);\Bs\\
\hline\end{tabular}\\}
%
\\ \hspace*{1.cm} {
\ttfamily\vspace{.3cm}
\begin{tabular}[H]{|l|}
\multicolumn{1}{c}{\rmfamily \bfseries Return with V from SV Decomposition\vspace{.1cm}}\\ \hline\Ts
int vsip\_svdmatv\_f(const vsip\_sv\_f*, vsip\_scalar\_vi, \\*\hspace*{1cm}vsip\_scalar\_vi, const vsip\_mview\_f*);\Bs\\
int vsip\_csvdmatv\_f(const vsip\_csv\_f*, vsip\_scalar\_vi, \\*\hspace*{1cm}vsip\_scalar\_vi, const vsip\_cmview\_f*);\Bs\\
int vsip\_svdmatv\_d(const vsip\_sv\_d*, vsip\_scalar\_vi, \\*\hspace*{1cm}vsip\_scalar\_vi, const vsip\_mview\_d*);\Bs\\
int vsip\_csvdmatv\_d(const vsip\_csv\_d*, vsip\_scalar\_vi, \\*\hspace*{1cm}vsip\_scalar\_vi, const vsip\_cmview\_d*);\Bs\\
\hline\end{tabular}\\}
%
\\\pyjvsiph
% table of flags and types
\begin{table}
\caption{Flags and Types for SV Decomposition}
\begin{center}\begin{tabular}{|l l|}
\multicolumn{2}{c}{\Ts\parbox[t]{.6\textwidth}{\center{\rmfamily \bfseries SV Decomposition Types}}}\Bs\\\hline
'sv\_d' & Real \ttbf{SV}; double precision \Bs\\\hline
'sv\_f' & Real \ttbf{SV}; float precision\Bs\\\hline
'csv\_d' & Complex \ttbf{SV}; double precision\Bs\\\hline
'csv\_f' & Complex \ttbf{SV}; float precision\Bs\\\hline
%%%
\multicolumn{2}{c}{\parbox[t]{.6\textwidth}{\center{\rmfamily \bfseries Flags \ttbf{opU} and \ttbf{opV} specifying computing options for matrices \ttbf{U} and \ttbf{V}}}}\Bs\\\hline
\Ts'NOS' or \ttbf{VSIP\_SVD\_UVNOS} & Do not compute.\Bs\\\hline
'FULL' or \ttbf{VSIP\_SVD\_UVFULL} & Compute full matrix including null space.\Bs\\\hline
'PART' or \ttbf{VSIP\_SVD\_UVPART} & Compute matrix without the null space.\Bs\\\hline
%%%
\multicolumn{2}{c}{\parbox[t]{.6\textwidth}{\center{\rmfamily \bfseries Matrix Operator Flags (\ttbf{op})}}}\Bs\\\hline
\Ts'NTRANS' or \ttbf{VSIP\_MAT\_NTRANS} & No Transpose operator\Bs\\\hline
   'TRANS' or \ttbf{VSIP\_MAT\_TRANS} & Transpose operator\Bs\\\hline
   'HERM' or \ttbf{VSIP\_MAT\_HERM} & Hermitian operator\Bs\\\hline
%%%
\multicolumn{2}{c}{\parbox[t]{.6\textwidth}{\center{\rmfamily \bfseries Side Flag for \ttbf{matu} and \ttbf{matv}}}}\Bs\\\hline
\Ts'LSIDE' or \ttbf{VSIP\_MAT\_LSIDE} & \ttbf{U} or \ttbf{V} Matrix on the left side\Bs\\\hline
   'RSIDE' or \ttbf{VSIP\_MAT\_RSIDE} & \ttbf{U} or \ttbf{V} Matrix on the right side\Bs\\\hline
 \end{tabular}\end{center}\end{table}
%%
\\\hspace*{.8cm}{\textbf{View Methods\vspace{.2cm}}\\
%
\hspace*{.8cm}{\textbf{LU Class Methods\vspace*{.2cm}}\\
\hspace*{1.cm}\parbox{.9\textwidth}{To create an \ttbf{SV} object do\\
\hspace*{1.cm}\ttbf{svObj = SV(t,m,n,opU,opV)} \\
Where \ttbf{t} is a string indicating the type of \ttbf{SV} object to create, \ttbf{m} and \ttbf{n} indicate the size (\ttbf{m,n}) of the input matrix to decompose, and \ttbf{opU} and  \ttbf{opV} are flags specifying computing options for matrices \ttbf{U} and \ttbf{V} respectively.\\
For the class methods table we assume we have created an SV object we call \ttbf{svObj} and we have an input matrix \ttbf{view A} compliant with \ttbf{svObj}.\vspace{.2cm}}\\
