\afuncT{svd}{Singular Value Decomposition Class}{singularValueDecompostion}
\\\cvsiplh 
\\ \hspace*{.8cm} \vspace*{.1cm} \textbf{Available Functions }
%
%\\ \hspace*{.8cm} \vspace*{.1cm} \texttt{svd\_create}
\\ \hspace*{.03\textwidth} {
\ttfamily\vspace{.3cm}
\begin{tabular}[H]{|l|}
\multicolumn{1}{c}{\rmfamily \bfseries Create SVD Object\vspace{.1cm}}\\ \hline \Ts
vsip\_sv\_d* vsip\_svd\_create\_d(vsip\_length, vsip\_length,\\*\hspace*{1cm}vsip\_svd\_uv , vsip\_svd\_uv);\Bs\\
vsip\_sv\_f* vsip\_svd\_create\_f(vsip\_length, vsip\_length,\\*\hspace*{1cm}vsip\_svd\_uv , vsip\_svd\_uv);\Bs\\
vsip\_csv\_d* vsip\_csvd\_create\_d(vsip\_length, vsip\_length,\\*\hspace*{1cm}vsip\_svd\_uv , vsip\_svd\_uv);\Bs\\
vsip\_csv\_f* vsip\_csvd\_create\_f(vsip\_length, vsip\_length,\\*\hspace*{1cm}vsip\_svd\_uv , vsip\_svd\_uv);\Bs\\
\hline\end{tabular}\\}
%
%\\ \hspace*{.8cm} \vspace*{.1cm} \texttt{svd\_destroy}
\\ \hspace*{.03\textwidth} {
\ttfamily\vspace{.3cm}
\begin{tabular}[H]{|l|}
\multicolumn{1}{c}{\rmfamily \bfseries Destroy SVD Object\vspace{.1cm}}\\ \hline\Ts
int vsip\_svd\_destroy\_d(vsip\_sv\_d*);\Bs\\
int vsip\_svd\_destroy\_f(vsip\_sv\_f*);\Bs\\
int vsip\_csvd\_destroy\_d(vsip\_csv\_d*);\Bs\\
int vsip\_csvd\_destroy\_f(vsip\_csv\_f*);\Bs\\
\hline\end{tabular}\\}
%
%\\ \hspace*{.8cm} \vspace*{.1cm} \texttt{svd}
\\ \hspace*{.03\textwidth}{
\ttfamily\vspace{.3cm}
\begin{tabular}[H]{|l|}
\multicolumn{1}{c}{\rmfamily \bfseries Compute SVD\vspace{.1cm}}\\ \hline \Ts
int vsip\_svd\_d(vsip\_sv\_d*, const vsip\_mview\_d*, vsip\_vview\_d*);\Bs\\
int vsip\_svd\_f(vsip\_sv\_f*, const vsip\_mview\_f*, vsip\_vview\_f*);\Bs\\
int vsip\_csvd\_d(vsip\_csv\_d*, const vsip\_cmview\_d*, vsip\_vview\_d*);\Bs\\
int vsip\_csvd\_f(vsip\_csv\_f*, const vsip\_cmview\_f*, vsip\_vview\_f*);\Bs\\
\hline\end{tabular}\\}
%
%\\ \hspace*{.8cm} \vspace*{.1cm} \texttt{svd\_getattr}
\\ \hspace*{.03\textwidth}{
\ttfamily\vspace{.3cm}
\begin{tabular}[H]{|l|}
\multicolumn{1}{c}{\rmfamily \bfseries Fill SVD Attribute Structure\vspace{.1cm}}\\ \hline \Ts
void vsip\_svd\_getattr\_d(const vsip\_sv\_d*,  vsip\_sv\_attr\_d*);\Bs\\
void vsip\_svd\_getattr\_f(const vsip\_sv\_f*,  vsip\_sv\_attr\_f*);\Bs\\
void vsip\_csvd\_getattr\_d(const vsip\_csv\_d*,  vsip\_csv\_attr\_d*);\Bs\\
void vsip\_csvd\_getattr\_f(const vsip\_csv\_f*,  vsip\_csv\_attr\_f*);\Bs\\
\hline\end{tabular}\\}
%
\\ \hspace*{0.4cm} {
\ttfamily\vspace{.3cm}
\begin{tabular}[H]{|l|}
\multicolumn{1}{c}{\rmfamily \bfseries Product with U from SV Decomposition\vspace{.1cm}}\\ \hline\Ts
\Ts int vsip\_svdprodu\_f(const vsip\_sv\_f*,vsip\_mat\_op, vsip\_mat\_side,\\*\hspace*{1cm}const vsip\_mview\_f*);\Bs\\
int vsip\_csvdprodu\_f(const vsip\_csv\_f*, vsip\_mat\_op, vsip\_mat\_side,\\*\hspace*{1cm}const vsip\_cmview\_f*);\Bs\\
int vsip\_svdprodu\_d(const vsip\_sv\_d*, vsip\_mat\_op, vsip\_mat\_side,\\*\hspace*{1cm}const vsip\_mview\_d*);\Bs\\
int vsip\_svdprodu\_f(const vsip\_sv\_f*, vsip\_mat\_op, vsip\_mat\_side,\\*\hspace*{1cm}const vsip\_mview\_f*);\Bs\\
int vsip\_csvdprodu\_d(const vsip\_csv\_d*, vsip\_mat\_op, vsip\_mat\_side,\\*\hspace*{1cm}const vsip\_cmview\_d*);\Bs\\
int vsip\_csvdprodu\_f(const vsip\_csv\_f*, vsip\_mat\_op, vsip\_mat\_side,\\*\hspace*{1cm}const vsip\_cmview\_f*);\Bs\\
\hline\end{tabular}\\}
%
\\ \hspace*{0.4cm} {
\ttfamily\vspace{.3cm}
\begin{tabular}[H]{|l|}
\multicolumn{1}{c}{\rmfamily \bfseries Product with U from SV Decomposition\vspace{.1cm}}\\ \hline \Ts
int vsip\_svdprodv\_f(const vsip\_sv\_f*,vsip\_mat\_op, vsip\_mat\_side,\\*\hspace*{1cm}const vsip\_mview\_f*);\Bs\\
int vsip\_csvdprodv\_f(const vsip\_csv\_f*, vsip\_mat\_op, vsip\_mat\_side,\\*\hspace*{1cm}const vsip\_cmview\_f*);\Bs\\
int vsip\_svdprodv\_d(const vsip\_sv\_d*, vsip\_mat\_op, vsip\_mat\_side,\\*\hspace*{1cm}const vsip\_mview\_d*);\Bs\\
int vsip\_svdprodv\_f(const vsip\_sv\_f*, vsip\_mat\_op, vsip\_mat\_side,\\*\hspace*{1cm}const vsip\_mview\_f*);\Bs\\
int vsip\_csvdprodv\_d(const vsip\_csv\_d*, vsip\_mat\_op, vsip\_mat\_side,\\*\hspace*{1cm}const vsip\_cmview\_d*);\Bs\\
int vsip\_csvdprodv\_f(const vsip\_csv\_f*, vsip\_mat\_op, vsip\_mat\_side,\\*\hspace*{1cm}const vsip\_cmview\_f*);\Bs\\
\hline\end{tabular}\\}
%
\\ \hspace*{.03\textwidth} {
\ttfamily\vspace{.3cm}
\begin{tabular}[H]{|l|}
\multicolumn{1}{c}{\rmfamily \bfseries Return with U from SV Decomposition\vspace{.1cm}}\\ \hline\Ts
int vsip\_svdmatu\_f(const vsip\_sv\_f*, vsip\_scalar\_vi, \\*\hspace*{1cm}vsip\_scalar\_vi, const vsip\_mview\_f*);\Bs\\
int vsip\_csvdmatu\_f(const vsip\_csv\_f*, vsip\_scalar\_vi, \\*\hspace*{1cm}vsip\_scalar\_vi, const vsip\_cmview\_f*);\Bs\\
int vsip\_svdmatu\_d(const vsip\_sv\_d*, vsip\_scalar\_vi, \\*\hspace*{1cm}vsip\_scalar\_vi, const vsip\_mview\_d*);\Bs\\
int vsip\_csvdmatu\_d(const vsip\_csv\_d*, vsip\_scalar\_vi, \\*\hspace*{1cm}vsip\_scalar\_vi, const vsip\_cmview\_d*);\Bs\\
\hline\end{tabular}\\}
%
\\ \hspace*{.03\textwidth} {
\ttfamily\vspace{.3cm}
\begin{tabular}[H]{|l|}
\multicolumn{1}{c}{\rmfamily \bfseries Return with V from SV Decomposition\vspace{.1cm}}\\ \hline\Ts
int vsip\_svdmatv\_f(const vsip\_sv\_f*, vsip\_scalar\_vi, \\*\hspace*{1cm}vsip\_scalar\_vi, const vsip\_mview\_f*);\Bs\\
int vsip\_csvdmatv\_f(const vsip\_csv\_f*, vsip\_scalar\_vi, \\*\hspace*{1cm}vsip\_scalar\_vi, const vsip\_cmview\_f*);\Bs\\
int vsip\_svdmatv\_d(const vsip\_sv\_d*, vsip\_scalar\_vi, \\*\hspace*{1cm}vsip\_scalar\_vi, const vsip\_mview\_d*);\Bs\\
int vsip\_csvdmatv\_d(const vsip\_csv\_d*, vsip\_scalar\_vi, \\*\hspace*{1cm}vsip\_scalar\_vi, const vsip\_cmview\_d*);\Bs\\
\hline\end{tabular}\\}
%
\\\pyjvsiph
% table of flags and types
\begin{table}
\caption{Flags and Types for SV Decomposition}
\label{tab:svdFlagsAndType}
\begin{center}\begin{tabular}{|l l|}
\multicolumn{2}{c}{\Ts\parbox[t]{.6\textwidth}{\center{\rmfamily \bfseries SV Decomposition Types}}\vspace*{1mm}}\Bs\\\hline
'sv\_d' & Real \ttbf{SV}; double precision \Bs\\\hline
'sv\_f' & Real \ttbf{SV}; float precision\Bs\\\hline
'csv\_d' & Complex \ttbf{SV}; double precision\Bs\\\hline
'csv\_f' & Complex \ttbf{SV}; float precision\Bs\\\hline
%%%
\multicolumn{2}{c}{\parbox[t]{.6\textwidth}{\center{\rmfamily \bfseries Flags \ttbf{opU} and \ttbf{opV} specifying computing options for matrices \ttbf{U} and \ttbf{V}}}\vspace*{1mm}}\Bs\\\hline
\Ts'NOS' or \ttbf{VSIP\_SVD\_UVNOS} & Do not compute.\Bs\\\hline
'FULL' or \ttbf{VSIP\_SVD\_UVFULL} & Compute full matrix including null space.\Bs\\\hline
'PART' or \ttbf{VSIP\_SVD\_UVPART} & Compute matrix without the null space.\Bs\\\hline
%%%
\multicolumn{2}{c}{\parbox[t]{.6\textwidth}{\center{\rmfamily \bfseries Matrix Operator Flags (\ttbf{op})}}\vspace*{1mm}}\Bs\\\hline
\Ts'NTRANS' or \ttbf{VSIP\_MAT\_NTRANS} & No Transpose operator\Bs\\\hline
   'TRANS' or \ttbf{VSIP\_MAT\_TRANS} & Transpose operator\Bs\\\hline
   'HERM' or \ttbf{VSIP\_MAT\_HERM} & Hermitian operator\Bs\\\hline
%%%
\multicolumn{2}{c}{\parbox[t]{.6\textwidth}{\center{\rmfamily \bfseries Side Flag for \ttbf{matu} and \ttbf{matv}}}\vspace*{1mm}}\Bs\\\hline
\Ts'LSIDE' or \ttbf{VSIP\_MAT\_LSIDE} & \ttbf{U} or \ttbf{V} Matrix on the left side\Bs\\\hline
   'RSIDE' or \ttbf{VSIP\_MAT\_RSIDE} & \ttbf{U} or \ttbf{V} Matrix on the right side\Bs\\\hline
 \end{tabular}\end{center}\end{table}
%%
\\\hspace*{.8cm}{\textbf{View Methods\vspace{.2cm}}\\
\hspace*{.04\textwidth}\parbox{.93\textwidth}{
\begin{itemize}
\item{For singular value decomposition the input matrix is overwritten and (basically) owned by the SVD. To retain the calling \ttbf{view} make a copy.}
\item{Five view methods have been defined for the SVD.}
\subitem{\ttbf{sv}\hspace{6.5mm}\parbox[t]{.7\textwidth}{A property to obtain a vector of singular values for the calling \ttbf{view}}}
\subitem{\ttbf{svd }\hspace{2mm}\parbox[t]{.7\textwidth}{A property to obtain full \ttbf{U}, \ttbf{s} and \ttbf{V} \ttbf{view}s for a calling \ttbf{view}}}
\subitem{\ttbf{svdP }\parbox[t]{.7\textwidth}{A property to obtain \ttbf{U}, \ttbf{s} and \ttbf{V} \ttbf{view}s for a calling \ttbf{view} without the null space (\ttbf{SV} with the 'PART' option).}}
\subitem{\ttbf{svdU }\parbox[t]{.7\textwidth}{A property to obtain full \ttbf{U} and \ttbf{s} \ttbf{view}s for a calling \ttbf{view}. \ttbf{V} is not calculated.}}
\subitem{\ttbf{svdV }\parbox[t]{.7\textwidth}{A property to obtain \ttbf{s} and full \ttbf{V} \ttbf{view}s for a calling \ttbf{view}. \ttbf{U} is not calculated.}}
\end{itemize}\vspace*{2mm}}}\\
%EXAMPLE
\hspace*{1.1cm}\textbf{Example: }\vspace*{.1cm}\\
\hspace*{1.9cm}\parbox{.85\textwidth}{\Ts Assume matrix \ttbf{view} \ttbf{A} has been created and has data in it.}\\
\hspace*{1.9cm}\parbox{.8\textwidth}{\vspace{.3cm}\hspace*{1cm}\ttbf{s=A.sv} \\*
will calculate a vector of singular vales for \ttbf{A}. To retain \ttbf{A} use \ttbf{s=A.copy.sv}\vspace*{3mm}}\\
%CLASS METHODS
\hspace*{.8cm}{\textbf{SV Class Methods\vspace*{2mm}}\\
\hspace*{.03\textwidth}\parbox{.9\textwidth}{To create an \ttbf{SV} object do\\
\hspace*{.03\textwidth}\ttbf{svObj = SV(t,m,n,opU,opV)} \\
Where \ttbf{t} is a string indicating the type of \ttbf{SV} object to create, \ttbf{m} and \ttbf{n} indicate the size (\ttbf{m,n}) of the input matrix to decompose, and \ttbf{opU} and  \ttbf{opV} are flags specifying computing options for matrices \ttbf{U} and \ttbf{V} respectively. See table \ref{tab:svdFlagsAndType}.\\
For convenience if the target of method \ttbf{svd} is matrix \ttbf{view A} then you may create a compatible \ttbf{SV} object using\\
\hspace*{.03\textwidth}\ttbf{svObj=SV(A.type,A.size,opU,opV)}\\
For the class methods table we assume we have created an \ttbf{SV} object we call \ttbf{svObj} and we have an input matrix \ttbf{view A} compliant with \ttbf{svObj}.\vspace{.2cm}}\\
\hspace*{.03\textwidth}\parbox{.9\textwidth}{For methods \ttbf{prodU} and \ttbf{prodV} the input/output matrix \ttbf{XB} may have a different size on output. Both views are in the same data space and will overlap (this is an in-place operation). To ensure matrix \ttbf{XB} is sized properly make sure it is large enough to hold all the data for the largest matrix and place the other matrix in a subview with origin at \ttbf{0,0} for both input and output. Note that \pyjv{} has functions \ttbf{sizeIn} and \ttbf{sizeOut} to help in calculating sizes given the somewhat confusing number of options for matrix operators and matrix sides available in matrix product functions.}\\
\hspace*{.03\textwidth}\parbox[t]{.94\textwidth}{\begin{tabular}{|l|l|}
\multicolumn{2}{c}{\parbox[t]{.58\textwidth}{\center{\rmfamily \bfseries SV Decomposition Methods}\vspace*{2mm}}}\Bs\\ \hline
%
\Ts\ttbf{svObj.svd(A)} & 
\parbox[t]{.58\textwidth}{Decompose \ttbf{A}. Results are in SV object.\vspace*{1mm}}\Bs\\\hline
%
\ttbf{svObj.sizeU} & 
\parbox[t]{.58\textwidth}{Property. Returns size of U matrix created by \ttbf{svd} method.\vspace*{2mm}}\Bs\\\hline
%
\ttbf{svObj.sizeV} & 
\parbox[t]{.58\textwidth}{Property. Returns size of V matrix created by \ttbf{svd} method.\vspace*{2mm}}\Bs\\\hline
%
\ttbf{svObj.size} & 
\parbox[t]{.58\textwidth}{Property. Returns size of expected input matrix to \ttbf{svd} method \ttbf{(m,n)}\vspace{1mm}}\Bs\\\hline
%
\ttbf{svObj.type} & 
\parbox[t]{.58\textwidth}{Property. Returns string indicating SV type.\vspace*{2mm}}\Bs\\\hline
%
\ttbf{svObj.vsip} & 
\parbox[t]{.58\textwidth}{Property. Returns C VSIPL SV instance.\vspace*{2mm}}\Bs\\\hline
%
\ttbf{svObj.s} &
 \parbox[t]{.58\textwidth}{Property. Returns vector of singular values.\vspace*{1mm}}\Bs\\\hline
%
\ttbf{svObj.matU(low,high,U)} &
 \parbox[t]{.58\textwidth}{Method to get matrix \ttbf{U} from \ttbf{SV} object.  Arguments \ttbf{low} and \ttbf{high} are indices of the first and last column to be returned. Argument \ttbf{U} is the supplied output matrix of proper size. For convenience one may do \ttbf{U = svObj.matU(low,high)} to have the method create the U matrix for you. For convenience one may do \ttbf{U = svObj.matU()} if the entire available \ttbf{U} matrix is desired.\vspace{2mm}}\Bs\\\hline
%
\ttbf{svObj.matV(low,high,V)} &
 \parbox[t]{.58\textwidth}{Method to get matrix \ttbf{V} from \ttbf{SV} object. The \ttbf{matV} method has same optional argument lists as \ttbf{matU}.\vspace*{2mm}}\Bs\\\hline
%
\ttbf{svObj.prodU(op,side,XB)} &
 \parbox[t]{.58\textwidth}{Matrix product of \ttbf{U} with \ttbf{XB}. Input/Output in \ttbf{XB}.\vspace*{1mm}}\Bs\\\hline
%
\ttbf{svObj.prodV(op,side,XB)} &
 \parbox[t]{.58\textwidth}{Matrix product of \ttbf{V} with \ttbf{XB}. Input/Output in \ttbf{XB}.\vspace*{1mm}}\Bs\\\hline
%
\end{tabular}\vspace*{.4cm}}\\
