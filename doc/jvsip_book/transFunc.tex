\afuncT{trans}{Matrix transpose. This function is done out of place unless the input Matrix
is square and the input and output matrix resolve to the same object; otherwise the function
moves data from an input matrix into an output matrix.}{matrixOperations}
\\\cvsiplh
\\\hspace*{.06\textwidth}\parbox{.94\textwidth}{\raggedright The output matrix must be created of 
the proper size and attributes to accomodate the transpose of the input data.\Bs}
\begin{cfuncs}
void vsip\_mtrans\_f(const~vsip\_mview\_f*, const~vsip\_mview\_f*);\Bs\\
void vsip\_cmtrans\_f(const~vsip\_cmview\_f*, const~vsip\_cmview\_f*);\Bs\\
void vsip\_mtrans\_d(const~vsip\_mview\_d*, const~vsip\_mview\_d*);\Bs\\
void vsip\_cmtrans\_d(const~vsip\_cmview\_d*, const~vsip\_cmview\_d*);\Bs\\
\end{cfuncs}
\pyjvsiph
\viewmthd{yes}{yes}{No}{out=in.trans}
\apyfunc{yes}{out = trans(in,out)}
\pyComment{
\item {The \ttbf{trans} method creates a compact row major matrix of the proper
type to store the output of the transpose and returns it.  The method is defined as a 
property since no arguments are required and is always done out-of-place}
\item{The \ttbf{trans} function works much the same as the C VSIPL version except that a 
convenience pointer to the output view is returned. This must be done out-of-place unless
the matrix is square.}
}
