\chapter{Functions}
\section*{Introduction}
In this chapter I give basic usage information for the functions included in the JVSIP implementation of the C VSIPL specification and also related information for the \pyjv python module.  There are many functions so I may miss a few.

Usage information may also be found by reading the C VSIPL specification, either the old one included with the JVSIP distribution or the newer one developed by the HPEC working group of the OMG.  I currently recommend sticking with the old one included with the JVSIP distribution.  There is a lot of information about C VSIPL in the specification so C VSIPL information in this document will not be extensive; and since \pyjv has no specification document I will spend more time covering the \pyjv methodology.

I try and include information on the \pyjv methods and functions collocated with the corresponding C VSIPL information.  Reading the pyJvsip.py module file is also encouraged.  \ttbf{PyJvsip} includes some functionality not (directly) part of C VSIPL.  I will try and highlight these special cases.  

For python information the python help mechanism has also been supported somewhat; but keeping that information correct, up-to-date, and available for every function is a work in progress. 

Keep in mind this chapters main purpose is as a go-to reference for proper incantations when writing code. Except for the introductory sections it is probably not something you will want to read.

In order to have some reasonable ordering of the functions the alphabetical listing is based upon a root function name, not the actual vsip function. For instance the second function in the list is the \ilCode{add} function. There are several \ilCode{add} functions in the Core profile. All of them are placed together under \ilCode{add}.

When a C VSIPL function requires a special object it needs support functions to create the object, and destroy it, and perhaps query it for its attributes. For instance to do a discrete Fourier transform one needs a function to create an FFT object, a function to do the actual FFT using the FFT object, and a function to destroy the FFT object when it is no longer needed. The author calls functions which are designed to work together to do a single job function sets. Function sets are placed together under a single heading. For instance all the functions involved with doing an FFT are placed under the FFT heading.

As discussed in chapter one python supports polymorphism, and object oriented programing. A \pyjv object is an instantiation of a python class definition. The python object will contain a C VSIPL object as an instance variable as well as other information needed by \pyjv. For this reason the python garbage collector will destroy C VSIPL objects when no reference to the \pyjv object exists.

Because of the true object oriented nature of \pyjv there are methods defined for every class which accomplish most of the functionality of C VSIPL. \ttbf{PyJvsip} also defines many functions which operate on the \pyjv objects. Frequently you can use either a method or a function. This information is reflected in the JVSIP function list.

No attempt is made to be exhaustive in the function descriptions. Those interested in more detail are directed to the VSIPL specification document included with the JVSIP distribution. In addition various examples included in this document will provide more detail on the use of some of the more complicated functions.
%
\section*{C VSIPL Specification}\addcontentsline{toc}{section}{C VSIPL Specification}
The main document on which \ttbf{JVSIP} is based is the \emph{VSIPL 1.3 API} as approved by the VSIPL Forum on January 31, 2008.  That document is included with the \ttbf{JVSIP} distribution.  The main purpose of this section is to provide a roadmap for people who are familiar with the C VSIPL specification to get around in this \ttbf{JVSIP} manual.  Here I provide tables in an order matching the \emph{VSIPL 1.3 API} specification with links to the same information as presented  in the \ttbf{JVSIP} manual.
    \input{VSIP1p3Chapters} %table of
\subsection*{Summary of VSIPL Types}\addcontentsline{toc}{subsection}{Summary of VSIPL Types}
\subsection*{Support Functions}\addcontentsline{toc}{subsection}{Support Functions}
    \input{VSIP1p3SupportFunctions}
\subsubsection*{Initialize and Finalize Operations}\addcontentsline{toc}{subsubsection}{Initialize and Finalize Operations}
    \input{InitSupport} %table of
\subsubsection*{Block Objects}\addcontentsline{toc}{subsubsection}{Block Class}
    \input{BlockSupport} % table of
\subsubsection*{View Objects}\addcontentsline{toc}{subsubsection}{View Class}
    \input{VectorSupport}% table of
    \input{MatrixSupport} % table of
    \input{TensorSupport}% table of
\subsection*{Scalar Functions}\addcontentsline{toc}{subsection}{Scalar Functions}
In general I do not define scalar functions in \pyjv.  Ease of use is a major goal of the \pyjv module and to further this goal I decided scalars used by or returned by \pyjv functions should be normal python scalars. Using scalar functions (such as $\cos$, $\sin$, etc.) imported from the math module or the numpy module should work fine. That said, you can always use the C VSIPL scalar functions directly since they are in the \ttbf{vsip} module which is included in the \pyjv module.
\subsection*{Random Number Generation}\addcontentsline{toc}{subsection}{Random Number Generation}
\subsection*{Elementwise Operations}\addcontentsline{toc}{subsection}{Elementwise Operations}
Elementwise operatons are simple operations which are done on each element in a matrix or vector. Most of the time, when more than one \ttbf{view} is input, the \ttbf{view} shapes will need to be the same since the operation is done to identically indexed elements for each input \ttbf{view} and the operation result is placed in an identically indexed element of the output \ttbf{view}. 

The tables referenced in this section list elementwise operations with a link to the corresponding function page. Although the function pages are alphabetical, the lists here are in the same order (although not necessarily identical) to the order they appear in the C VSIPL specification.
    \input{VSIP1p3ElementwiseFunctions}
    \input{ElementaryMath.tex}
    \input{UnaryOperations.tex}
    \input{BinaryOperations.tex}
    \input{TernaryOperations.tex}
    \input{LogicalOperations.tex}
    \input{SelectionOperations.tex}
    \input{BitwiseOperators.tex}
    \input{ElementGenerationOperations.tex}
    \input{ManipulationOperations.tex}
\subsection*{Signal Processing Functions}\addcontentsline{toc}{subsection}{Signal Processing Functions}
    \input{VSIP1p3SignalProcessingFunctions}
\input{FftFunctions}
%
\subsubsection*{Convolution and Correlation Functions} 
\addcontentsline{toc}{subsubsection}{Convolution and Correlation Functions}
\input{ConvCorrFunctions}
%
\input{WindowFunctions}
%
\subsubsection*{Filter Functions} \addcontentsline{toc}{subsubsection}{Filter Functions}
\input{FilterFunctions}
%
\subsubsection*{Miscellaneous Signal Processing Functions} \addcontentsline{toc}{subsubsection}{Miscellaneous Signal Processing Functions}
\input{miscSigProcFunctions}
%
\subsection*{Linear Algebra Functions}\addcontentsline{toc}{subsection}{Linear Algebra Functions}
    \input{VSIP1p3LinearAlgebraFunctions}
\subsection*{Implementation Dependent Input and Output}\addcontentsline{toc}{subsection}{Implementation Dependent Input and Output}
   \ttbf{JVSIP} does not support implementation dependent IO at this time.
\subsection*{VSIPL Addendum}\addcontentsline{toc}{subsection}{VSIPL Addendum}
Editing the VSIPL specification was becoming difficult because of its length and instabilities in the MS Word source document. When functions were added to the specification for interpolation, permutation and sorting they were added as separate documents in a addendum and basically glued onto the pdf. This allowed for much less editing of the MS Word source document.
\subsubsection*{VSIPL Interpolation}\addcontentsline{toc}{subsubsection}{VSIPL Interpolation}
\subsubsection*{VSIPL Permute}\addcontentsline{toc}{subsubsection}{VSIPL Permute}
\subsubsection*{VSIPL Sort}\addcontentsline{toc}{subsubsection}{VSIPL Sort}
\section*{VSIP Types}
This section covers the enumerated types and special structures. These are declared in the public header file \ilCode{vsip.h}.
 
\section*{JVSIP Function List}\addcontentsline{toc}{section}{JVSIP Function List}
The following pages are a list of available functions in JVSIP. The top part of each page will include a section of available C functions (basically extracted from \ilCode{vsip.h}). Since the VSIPL specification is the primary source of information for C VSIPL not much more is included. 

Following the list of available functions is information on how (and if) the function is supported by \pyjv. The \pyjv section of the function page is more extensive than the C information. Basically there is a line indicating if it is available (as a 	tbf{view} method), if it is a property, and if it is in-place. Then there is a line indicating if it is available as a \pyjv function. Finally there is a comment section with additional information.

Note that comments may follow the C VSIPL and/or pyJvsip section and may also follow both indicating the comments pertain to the entire page and not just C or Python.

\subsection*{PyJvsip Methods}\addcontentsline{toc}{subsection}{PyJvsip Methods}
We note that saying the method is a property means you call it without even an empty argument list. For instance if \ilCode{a} is a \pyjv \ttbf{view} then \ilCode{a.cos} will replace the values in \ilCode{a} with there cosine. Since it is a property we DON'T say \ilCode{a.cos()}. Frequently, but not always, view methods are done in-place and that is also indicated. If it is not done in-place then the method will construct an appropriate output \ttbf{view} and return it filled out with the appropriate values.

An example of a \ttbf{view} method that is not done in place is \ilCode{copy}. For instance \ilCode{b=a.copy} will produce a copy of \ilCode{a} in an appropriate view. Note the new \ttbf{b view} will be the same precision, shape and depth as the calling \ttbf{view} but the \ttbf block will be of an exact size and the stride information will be the minimum stride required for the \ttbf{view}. Additional information on copy is available on its function page.

This is the type of information included on the function pages. Since there seem to be many exceptions we won't provide a lot of rules; and instead refer to the function page.

\subsection*{PyJvsip Functions}\addcontentsline{toc}{subsection}{PyJvsip Functions}
In the \pyjv \ttbf{Function} section we provide information on function calls. For pyJvsip python function calls correspond closely with their C counterpart except that the shape, depth and precision are determined by the argument types used in the call and not by the actual name as is used by C VSIPL.

Not all C functions have a corresponding \pyjv function call. In particular most functions that return a value will be handled using a view method with no need for a function.
 
\input{addFunc}\input{acosFunc}\input{amFunc}\input{argFunc}\input{asinFunc}
\input{atanFunc}\input{atan2Func}
\input{blockadmitFunc}
\input{ceilFunc}\input{convFunc}\input{corrFunc}
\input{cosFunc}\input{coshFunc}\input{ceilFunc}\input{conjFunc}
\input{cumsumFunc}\input{copyFunc}
\input{divFunc}
\input{eulerFunc}\input{expFunc}\input{exp10Func}
\input{logFunc}\input{log10Func}
\input{fftFunc}\input{firFunc}
\input{floorFunc}
\input{ludFunc}
\input{maFunc}\input{magFunc}\input{magsqFunc}\input{meanvalFunc}
\input{meansqvalFunc}\input{modulateFunc}\input{msbFunc}
\input{negFunc}
\input{recipFunc}\input{roundFunc}\input{rsqrtFunc}
\input{sbmFunc}\input{sinFunc}\input{sinhFunc}\input{sqrtFunc}
\input{sqFunc}\input{sumvalFunc}
\input{sumsqvalFunc}
\input{tanFunc}\input{tanhFunc}