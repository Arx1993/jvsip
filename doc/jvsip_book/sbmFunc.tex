\afuncT{sbm}{Subtract and multiply. An element-wise function.}{ternaryOperations}
\\\cvsiplh
\afh
{
\ttfamily
\\\hspace*{.04\textwidth}\begin{tabular}[H]{l}
void vsip\_vsbm\_d(const vsip\_vview\_d*, const vsip\_vview\_d*,\\*\hspace{.7cm}const vsip\_vview\_d*, const vsip\_vview\_d*); 
void vsip\_vsbm\_f(const vsip\_vview\_f*, const vsip\_vview\_f*,\\*\hspace{.7cm}const vsip\_vview\_f*, const vsip\_vview\_f*); 
void vsip\_cvsbm\_d(const vsip\_cvview\_d*, const vsip\_cvview\_d*,\\*\hspace{.7cm}const vsip\_cvview\_d*, const vsip\_cvview\_d*); 
void vsip\_cvsbm\_f(const vsip\_cvview\_f*, const vsip\_cvview\_f*,\\*\hspace{.7cm}const vsip\_cvview\_f*, const vsip\_cvview\_f*); 
\end{tabular}
}
\\\pyjvsiph
\viewmthd{No}{NA}{NA}{NA}
\apyfunc{yes}{\ttbf{out = sbm(in1,in2,in3,out)}}
\pyComment{\item{Arguments \ttbf{in1}, \ttbf{in2} and \ttbf{in3} are always \ttbf{view}s. }
\item{The \ttbf{sbm} function works much the same as the C VSIPL version except that a convenience pointer to the output \ttbf{view} is returned.}
\item{This may be done in-place if an input \ttbf{view} is the same as the output \ttbf{view}.}}