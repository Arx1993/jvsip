\afuncT{fir}{Finite Impulse Response Class. See filter functions table}{filterFunctions}
\\\cvsiplh 
\\ \hspace*{.8cm} \vspace*{.1cm} \textbf{Available Functions }
%\\ \hspace*{.8cm} \vspace*{.1cm} \texttt{fir\_create}
\\ \hspace*{1.cm} {
\ttfamily
\begin{tabular}[H]{|l|}
\multicolumn{1}{c}{\rmfamily \bfseries FIR Create Functions\vspace{.1cm}}\\ \hline
vsip\_rcfir\_d* vsip\_rcfir\_create\_d(\\*\hspace{.6cm}const vsip\_vview\_d*, vsip\_symmetry, vsip\_length,\\*\hspace{.6cm}vsip\_length, vsip\_obj\_state, unsigned, vsip\_alg\_hint);\\
vsip\_rcfir\_f* vsip\_rcfir\_create\_f(\\*\hspace{.6cm}const vsip\_vview\_f*, vsip\_symmetry, vsip\_length,\\*\hspace{.6cm}vsip\_length, vsip\_obj\_state, unsigned, vsip\_alg\_hint);\\
vsip\_cfir\_d* vsip\_cfir\_create\_d(\\*\hspace{.6cm}const vsip\_cvview\_d*, vsip\_symmetry, vsip\_length,\\*\hspace{.6cm}vsip\_length, vsip\_obj\_state, unsigned, vsip\_alg\_hint);\\
vsip\_cfir\_f* vsip\_cfir\_create\_f(\\*\hspace{.6cm}const vsip\_cvview\_f*, vsip\_symmetry, vsip\_length,\\*\hspace{.6cm}vsip\_length, vsip\_obj\_state, unsigned, vsip\_alg\_hint);\\
vsip\_fir\_d* vsip\_fir\_create\_d(\\*\hspace{.6cm}const vsip\_vview\_d*, vsip\_symmetry, vsip\_length,\\*\hspace{.6cm}vsip\_length, vsip\_obj\_state, unsigned, vsip\_alg\_hint);\\
vsip\_fir\_f* vsip\_fir\_create\_f(\\*\hspace{.6cm}const vsip\_vview\_f*, vsip\_symmetry, vsip\_length,\\*\hspace{.6cm}vsip\_length, vsip\_obj\_state, unsigned, vsip\_alg\_hint);\\\hline
\end{tabular}\vspace{.1cm}
}
%\\ \hspace*{.8cm} \vspace*{.1cm} \texttt{fir\_destroy}
\\ \hspace*{1.cm} {
\ttfamily
\begin{tabular}[H]{|l|}
\multicolumn{1}{c}{\rmfamily \bfseries FIR Destroy Functions\vspace{.1cm}}\\ \hline
int vsip\_rcfir\_destroy\_d(vsip\_rcfir\_d*);\\
int vsip\_rcfir\_destroy\_f(vsip\_rcfir\_f*);\\
int vsip\_cfir\_destroy\_d(vsip\_cfir\_d*);\\
int vsip\_cfir\_destroy\_f(vsip\_cfir\_f*);\\
int vsip\_fir\_destroy\_d(vsip\_fir\_d*);\\
int vsip\_fir\_destroy\_f(vsip\_fir\_f*);\\\hline
\end{tabular}\vspace{.1cm}
}\vspace{.1cm}
%\\ \hspace*{.8cm} \vspace*{.1cm} \texttt{firflt}
\\ \hspace*{1.cm} {
\ttfamily
\begin{tabular}[H]{|l|}
\multicolumn{1}{c}{\rmfamily \bfseries FIR Filter Functions\vspace{.1cm}}\\ \hline
int vsip\_rcfirflt\_d(vsip\_rcfir\_d*, const vsip\_cvview\_d*,\\*\hspace{.7cm}const vsip\_cvview\_d*);\\
int vsip\_rcfirflt\_f(vsip\_rcfir\_f*, const vsip\_cvview\_f*,\\*\hspace{.7cm}const vsip\_cvview\_f*);\\
int vsip\_cfirflt\_d(vsip\_cfir\_d*, const vsip\_cvview\_d*,\\*\hspace{.7cm}const vsip\_cvview\_d*);\\
int vsip\_cfirflt\_f(vsip\_cfir\_f*, const vsip\_cvview\_f*,\\*\hspace{.7cm}const vsip\_cvview\_f*);\\
int vsip\_firflt\_d(vsip\_fir\_d*, const vsip\_vview\_d*,\\*\hspace{.7cm}const vsip\_vview\_d*);\\
int vsip\_firflt\_f(vsip\_fir\_f*, const vsip\_vview\_f*,\\*\hspace{.7cm}const vsip\_vview\_f*);\\\hline
\end{tabular}\vspace{.1cm}
}
\\
%\hspace*{.8cm} \texttt{fir\_getattr}
\hspace*{1.cm} {
\ttfamily
\begin{tabular}[H]{|l|}
\multicolumn{1}{c}{\rmfamily \bfseries Get FIR Attribute Functions\vspace{.1cm}}\\ \hline
void vsip\_rcfir\_getattr\_d(const vsip\_rcfir\_d*,\\*\hspace{.7cm}vsip\_rcfir\_attr*);\\
void vsip\_rcfir\_getattr\_f(const vsip\_rcfir\_f*,\\*\hspace{.7cm}vsip\_rcfir\_attr*);\\
void vsip\_cfir\_getattr\_d(const vsip\_cfir\_d*,\\*\hspace{.7cm}vsip\_cfir\_attr*);\\
void vsip\_cfir\_getattr\_f(const vsip\_cfir\_f*,\\*\hspace{.7cm}vsip\_cfir\_attr*);\\
void vsip\_fir\_getattr\_d(const vsip\_fir\_d*,\\*\hspace{.7cm}vsip\_fir\_attr*);\\
void vsip\_fir\_getattr\_f(const vsip\_fir\_f*,\\*\hspace{.7cm}vsip\_fir\_attr*);\\\hline
\end{tabular}\vspace{.1cm}
}\vspace{.1cm}
%\\\hspace*{.8cm} \texttt{fir\_reset}
\\ \hspace*{1.cm} {
\ttfamily
\begin{tabular}[H]{|l|}
\multicolumn{1}{c}{\rmfamily \bfseries Reset FIR Functions\vspace{.1cm}}\\ \hline
void vsip\_rcfir\_reset\_d(vsip\_rcfir\_d*)\\
void vsip\_rcfir\_reset\_f(vsip\_rcfir\_f*)\\
void vsip\_cfir\_reset\_d(vsip\_cfir\_d*)\\
void vsip\_cfir\_reset\_f(vsip\_cfir\_f*)\\
void vsip\_fir\_reset\_d(vsip\_fir\_d*)\\
void vsip\_fir\_reset\_f(vsip\_fir\_f*)\\\hline
\end{tabular}\\
}
%
\pyjvsiph
%
\\ \hspace*{.8cm}{\textbf{View Methods\vspace{.2cm}}\\
\hspace*{1cm}\parbox{.9\textwidth}{
\begin{itemize}
\item {A \ttbf{view} method has been defined for the kernel \ttbf{view}. The kernel is treated as non-symmetric so the entire kernel is assumed.\footnotemark[1]}
\item {A variable argument list is supported.} 
\subitem{The first required argument is the input data \ttbf{view}.}
\subitem {\parbox[t]{.8\textwidth}{The second optional argument is the decimation factor. It defaults to one.}\vspace*{.1cm}}
\item{Other parameters are either set to there default value, or are calculated from included parameters.\vspace{.2cm}}
\end{itemize}}\\
\hspace*{1.cm}\textbf{In-Place: }\hspace{.2cm} no\\
\hspace*{1.1cm}\textbf{Out-Of-Place: }\hspace{.2cm} yes\\
\hspace*{1.1cm}\textbf{Example: }\vspace*{.1cm}\\
\hspace*{1.9cm}\parbox{.82\textwidth}{Real FIR of real \ttbf{view x} given kernel \ttbf{view k} with default decimation 1.}\vspace*{.1cm}\\
\hspace*{2.5cm}\ttbf{y=k.firflt(x)}\vspace*{.1cm}\\
\hspace*{1.9cm}\parbox{.82\textwidth}{Complex FIR of complex \ttbf{view x} given real kernel \ttbf{view k} with user chosen decimation 3.}\vspace*{.1cm}\\
\hspace*{2.5cm}\ttbf{y=k.firflt(x,3)}\vspace*{.1cm}\\
\hspace*{1.9cm}\parbox{.82\textwidth}{Complex FIR of complex \ttbf{view x} given complex kernel \ttbf{view k} with default decimation 1.}\vspace*{.1cm}\\
\hspace*{2.5cm}\ttbf{y=k.firflt(x)}\vspace*{.1cm}\\
\hspace*{1.9cm}\parbox{.82\textwidth}{Note output \ttbf{view y} is created and returned by the method.}\\
%
\hspace*{.8cm}\textbf{FIR Class\vspace{.2cm}}\\
\hspace*{1.cm}\parbox{.9\textwidth}{To create an FIR object use \\*
\hspace*{1.cm} \ttbf{firObj=FIR(t,*args)}\\*
where \ttbf{args} is a tuple containing the create parameters for the FIR type selected, and \ttbf{t} is a string indicating the type of FIR to create.\vspace{.2cm}}\\
\hspace*{1.cm}\parbox{.9\textwidth}{Note \ttbf{args} will contain some or all of items listed in the FIR argument list in the order listed. The type string \ttbf{t} is shown in the FIR Types table below the argument list.}\\
\hspace*{1.cm}\parbox[t]{.9\textwidth}{
\begin{tabular}[t]{|l|l|}
\multicolumn{2}{c}{\parbox[t]{.68\textwidth}{\center{\rmfamily \bfseries Finite Impulse Response Argument List\vspace{.2cm}}}}\\ \hline
\ttbf{filt} & \parbox[t]{.74\textwidth}{A vector \ttbf{view} of filter coefficients.\\*Required argument \vspace*{.1cm}}\\ \hline
\ttbf{sym} & \parbox[t]{.74\textwidth}{Symmetry of \ttbf{filt} kernel. \\* Required argument\vspace*{.1cm}} \\\hline
\ttbf{N} & \parbox[t]{.74\textwidth}{Length of input data vector. \\* Required argument\vspace*{.1cm}}\\\hline
\ttbf{D} & \parbox[t]{.74\textwidth}{Decimation factor.\\* Required argument\vspace*{.1cm}}\\\hline
\ttbf{state} & \parbox[t]{.74\textwidth}{Flag to indicate if the filter state is to be saved.\\*
\ttbf{VSIP\_STATE\_SAVE} or \ttbf{VSIP\_STATE\_NO\_SAVE}\\* Argument is supported but defaults to not saving. \\* Instead of \ttbf{VSIP} flags you may use the strings \ttbf{'YES'} or \ttbf{'NO'}.\vspace*{.1cm}}\\ \hline
\ttbf{ntimes} & \parbox[t]{.74\textwidth}{Hint for how much the FIR object will be used. Zero indicates many times.\\*For \jv{} this argument is only supported at the interface level and defaults to zero.\vspace*{.1cm}} \\\hline
\ttbf{algHint} & \parbox[t]{.74\textwidth}{Algorithm hint to optimize for\\*speed (\ttbf{VSIP\_ALG\_TIME}),\\*size (\ttbf{VSIP\_ALG\_SPACE}),\\* or accuracy (\ttbf{VSIP\_ALG\_NOISE}).\\*For \jv{} this argument is only supported at the interface level and defaults to time.\vspace*{.1cm}}\\
\hline \end{tabular}\\
\begin{tabular}{|l|l|}
\multicolumn{2}{c}{\parbox[t]{.68\textwidth}{\center{\rmfamily \bfseries Finite Impulse Response Filter Types\vspace{.2cm}}}}\\ \hline
'fir\_f' & \parbox[t]{.68\textwidth}{Real \ttbf{FIR}; float precision \vspace*{.1cm}}\\\hline
'cfir\_f' & \parbox[t]{.68\textwidth}{ Complex \ttbf{FIR}; float precision \vspace*{.1cm}}\\\hline
'rcfir\_f' & \parbox[t]{.68\textwidth}{ Complex \ttbf{FIR} with real \ttbf{kernel}; float precision \vspace*{.1cm}}\\\hline
'fir\_d' & \parbox[t]{.68\textwidth}{ Real \ttbf{FIR}; double precision \vspace*{.1cm}}\\\hline
'cfir\_d' & \parbox[t]{.68\textwidth}{Complex \ttbf{FIR}; double precision \vspace*{.1cm}}\\\hline
'rcfir\_d' & \parbox[t]{.68\textwidth}{Complex \ttbf{FIR} with real \ttbf{kernel}; double precision \vspace*{.1cm}}\\\hline
\end{tabular}\vspace*{.4cm}}\\
%
\hspace*{.8cm}{\textbf{FIR Class Methods}\\
\hspace*{1.1cm} \parbox[t]{.9\textwidth}{For class methods table we assume we have created an FIR object we call \ttbf{firObj} and we have an input \ttbf{view x} compliant with \ttbf{firObj} and a compliant output \ttbf{view y}.\vspace{.2cm}}
\\
\hspace*{1.cm}\parbox[t]{.85\textwidth}{\begin{tabular}{|l|l|}
\multicolumn{2}{c}{\parbox[t]{.58\textwidth}{\center{\rmfamily \bfseries Finite Impulse Response Filter Methods\vspace{.2cm}}}}\\ \hline
\ttbf{firObj.flt(x,y)} & \parbox[t]{.58\textwidth}{Filter the data \ttbf{x} and place the results in \ttbf{y}}\\\hline
\ttbf{firObj.decimation} & \parbox[t]{.58\textwidth}{ Returns integer decimation factor. \vspace*{.1cm}}\\\hline
\ttbf{firObj.length} & \parbox[t]{.58\textwidth}{ Returns integer length for \ttbf{x}. \vspace*{.1cm}}\\\hline
\ttbf{firObj.lengthOut} & \parbox[t]{.58\textwidth}{ Returns integer of valid data points in \ttbf{y} \vspace*{.1cm}}\\\hline
\ttbf{firObj.reset} & \parbox[t]{.58\textwidth}{Resets FIR filter to its initial state. \vspace*{.1cm}}\\\hline
\ttbf{firObj.state} & \parbox[t]{.58\textwidth}{Returns \ttbf{True} if filter state is saved, otherwise returns \ttbf{False}.\vspace*{.1cm}}\\\hline
\ttbf{firObj.type} & \parbox[t]{.58\textwidth}{Returns string indicating filter type.\vspace*{.1cm}}\\\hline
\ttbf{firObj.vsip} & \parbox[t]{.58\textwidth}{Returns C VSIPL filter instance.\vspace*{.1cm}}\\\hline
\end{tabular}\vspace*{.4cm}}\\
\hspace*{.7cm} \parbox[t]{.91\textwidth}{
\begin{itemize}
\item{Methods \ttbf{decimation}, \ttbf{length}, \ttbf{state}, \ttbf{type} and \ttbf{vsip} are set when the FIR instance is created and do not change after create}
\item{Method \ttbf{lengthOut}\footnotemark[2] is calculated during the execution of method \ttbf{flt(x,y)} and is useful if state is saved and the filter object is used multiple times on a long piece of data.}
\item{Method \ttbf{reset} is used if state is saved and the filter is used multiple times on a long data set and then \emph{reset}\footnotemark[3] to its initial state for use on multiple long data sets.}
\end{itemize}}
\footnotetext[1]{This does not preclude symmetric kernels. You just need the entire kernel.}
\footnotetext[2]{See C VSIPL specification for more information on length of output data.}
\footnotetext[3]{See signal processing text on overlap-add and overlap-save filtering.}
