\afuncT{lle}{Logical less than or equal}{logicalOperations}
\\\cvsiplh
\afh
{
\ttfamily
\\\hspace*{.04\textwidth}\begin{tabular}[H]{l}
void vsip\_mlle\_d(\\*\hspace{1cm}const vsip\_mview\_d*, const vsip\_mview\_d*, const vsip\_mview\_bl*);\\
void vsip\_mlle\_f(\\*\hspace{1cm}const vsip\_mview\_f*, const vsip\_mview\_f*, const vsip\_mview\_bl*);\\
void vsip\_svlle\_f(\\*\hspace{1cm}vsip\_scalar\_f, const vsip\_vview\_f*, const vsip\_vview\_bl*);\\
void vsip\_svlle\_d(\\*\hspace{1cm}vsip\_scalar\_d, const vsip\_vview\_d*, const vsip\_vview\_bl*);\\
void vsip\_vlle\_d(\\*\hspace{1cm}const vsip\_vview\_d*, const vsip\_vview\_d*, const vsip\_vview\_bl*);\\
void vsip\_vlle\_f(\\*\hspace{1cm}const vsip\_vview\_f*, const vsip\_vview\_f*, const vsip\_vview\_bl*);\\
void vsip\_vlle\_i(\\*\hspace{1cm}const vsip\_vview\_i*, const vsip\_vview\_i*, const vsip\_vview\_bl*);\\
void vsip\_vlle\_si(\\*\hspace{1cm}const vsip\_vview\_si*, const vsip\_vview\_si*, const vsip\_vview\_bl*);\\
void vsip\_vlle\_uc(\\*\hspace{1cm}const vsip\_vview\_uc*, const vsip\_vview\_uc*, const vsip\_vview\_bl*);\\
\end{tabular}
}
\\\pyjvsiph
\viewmthd{Yes}{No}{No}{out=in.lle(arg)}
\apyfunc{Yes}{out = lle(in1,in2,out)}
\pyComment{
\item{For return value \ttbf{out} precision is of type \ttbf{\_bl} and shape is compliant with input \ttbf{view}s.}
\item{For method check is \ttbf{in <= arg} and for function check is \ttbf{in1 <= in2}.}
\item{For functions input \ttbf{in1} may be scalar for precisions of type \ttbf{\_f} and \ttbf{\_d} with vector shape. Other options are defined but have not been done for \jv{} at this time. The function will complain if comparisons are not available.}
\item{For methods if input \ttbf{arg} is a scalar it is converted to a constant vector with one element, stride of zero, and compliant length before the comparison. For this reason the \ttbf{view} method will work for some cases the function does not.
}
\item{One needs to be careful. The function call \ttbf{lle(aScalar,aVector,out)} is not the same as \ttbf{aVector.lle(aScalar)}. The first case checks if \ttbf{aScalar <= aVector} and the second case checks if \ttbf{aVector <= aScalar}}
}
