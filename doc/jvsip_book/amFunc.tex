\afuncT{am}{Add and multiply. An element-wise function.}{ternaryOperations}
\\\cvsiplh
\begin{cfuncs}
void vsip\_cvam\_d(const~vsip\_cvview\_d*,const~vsip\_cvview\_d*, const~vsip\_cvview\_d*, const~vsip\_cvview\_d*);\Bs\\
void vsip\_cvam\_f(const~vsip\_cvview\_f*,const~vsip\_cvview\_f*, const~vsip\_cvview\_f*, const~vsip\_cvview\_f*);\Bs\\
void vsip\_cvsam\_d(const~vsip\_cvview\_d*,vsip\_cscalar\_d, const~vsip\_cvview\_d*, const~vsip\_cvview\_d*);\Bs\\
void vsip\_cvsam\_f(const~vsip\_cvview\_f*,vsip\_cscalar\_f, const~vsip\_cvview\_f*, const~vsip\_cvview\_f*);\Bs\\
void vsip\_vam\_d(const~vsip\_vview\_d*, const~vsip\_vview\_d*, const~vsip\_vview\_d*, const~vsip\_vview\_d*);\Bs\\
void vsip\_vam\_f(const~vsip\_vview\_f*,const~vsip\_vview\_f*, const~vsip\_vview\_f*, const~vsip\_vview\_f*);\Bs\\
void vsip\_vsam\_d(const~vsip\_vview\_d*, vsip\_scalar\_d,const~vsip\_vview\_d*, const~vsip\_vview\_d*);\Bs\\
void vsip\_vsam\_f(const~vsip\_vview\_f*, vsip\_scalar\_f,  const~vsip\_vview\_f*, const~vsip\_vview\_f*);\Bs\\
\end{cfuncs}
\pyComment{
\item{The C VSIPL spec has separate man pages for add-multiply functions containing scalar arguments, and those containing only \ttbf{view} arguments.}}
\\\pyjvsiph
\viewmthd{No}{NA}{NA}{NA}
\apyfunc{yes}{\ttbf{out = am(in1,in2,in3,out)}}
\begin{comments}
\item{Argument \ttbf{in1} is always a \ttbf{view}, argument \ttbf{in2} is either a \ttbf{view} or a scalar and argument \ttbf{in3} is always a \ttbf{view}.}
\item{The \ttbf{am} function works much the same as the C VSIPL version except that a convenience pointer to the output \ttbf{view} is returned.}
\item{This may be done in-place if an input \ttbf{view} is the same as the output \ttbf{view}.}
\end{comments}