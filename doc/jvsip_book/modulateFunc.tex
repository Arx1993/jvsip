\afuncT{modulate}{Computes the modulation of a real vector by a specified complex frequency.}{unaryOperations}
\\\cvsiplh
\afh
\\\hspace*{.04\textwidth} {
\ttfamily
\begin{tabular}[H]{l}
vsip\_scalar\_d vsip\_cvmodulate\_d(\\*\hspace{.6cm}const vsip\_cvview\_d*, vsip\_scalar\_d, \\*\hspace{.6cm}vsip\_scalar\_d, const vsip\_cvview\_d*);\\
vsip\_scalar\_d vsip\_vmodulate\_d(\\*\hspace{.6cm}const vsip\_vview\_d*, vsip\_scalar\_d, \\*\hspace{.6cm}vsip\_scalar\_d, const vsip\_cvview\_d*);\\
vsip\_scalar\_f vsip\_cvmodulate\_f(\\*\hspace{.6cm}const vsip\_cvview\_f*, vsip\_scalar\_f, \\*\hspace{.6cm}vsip\_scalar\_f, const vsip\_cvview\_f*);\\
vsip\_scalar\_f vsip\_vmodulate\_f(\\*\hspace{.6cm}const vsip\_vview\_f*, vsip\_scalar\_f, \\*\hspace{.6cm}vsip\_scalar\_f, const vsip\_cvview\_f*);\\
\end{tabular}
}
\\\pyjvsiph
\viewmthd{No}{NA}{NA}{NA}
\apyfunc{Yes}{phiNew,out=modulate(in,nu,phi,out)}
\pyComment{
{\item{Note \ttbf{phi} is the initial phase and the final phase is returned as \ttbf{phiNew}. For \pyjv we also return a convenience copy of the output vector}}}