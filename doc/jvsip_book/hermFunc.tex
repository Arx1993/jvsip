\afuncT{herm}{Matrix Hermitian. This function must be done out-of-place unless the input
matrix is square.}{matrixOperations}
\\\cvsiplh
\\\hspace*{.06\textwidth}\parbox{.94\textwidth}{The output matrix must be created of the 
proper size and attributes to accomodate the transpose of the input data.\Bs}
\afh
\\\hspace*{.03\textwidth} {
\ttfamily
\begin{tabular}[H]{l}
void vsip\_cmherm\_f(\\*\hspace{.5cm}const vsip\_cmview\_f*, const vsip\_cmview\_f*);\Bs\\
void vsip\_cmherm\_d(\\*\hspace{.5cm}const vsip\_cmview\_d*, const vsip\_cmview\_d*);\Bs\\
\end{tabular}
}
\\ \hspace*{1.1cm} {
\ttfamily
\begin{tabular}[H]{l}
\end{tabular}
}
\\\pyjvsiph
\viewmthd{yes}{yes}{No}{out=in.herm}
\apyfunc{yes}{out = herm(in,out)}
\pyComment{
\item {The \ttbf{herm} method creates a compact row major matrix of the proper
type to store the output of the transpose and returns it.  The method is defined as a 
property since no arguments are required and is always done out-of-place}
\item{For the \ttbf{herm} method if the calling view is real then the transpose is returned.}
\item{The \ttbf{herm} function works much the same as the C VSIPL version except that a 
convenience pointer to the output view is returned. This must be done out-of-place unless
the matrix is square.}
}